java.pmd.intellij.plugin.textarea.rule.name=Rule Name:
java.pmd.intellij.plugin.textarea.rule.desc=Rule Desc:
java.pmd.intellij.plugin.textarea.pmd.rule.url=Pmd Url:
java.pmd.intellij.plugin.textarea.pmd.example=Rule Example:

java.best.practices.AbstractClassWithoutAbstractMethod.rule.msg=Abstract Class Without Abstract Method
java.best.practices.AbstractClassWithoutAbstractMethodRule.violation.msg = Abstract Class %s Without Abstract Method
java.best.practices.AbstractClassWithoutAbstractMethodRule.rule.desc=The abstract class does not contain any \
  abstract methods. An abstract class suggests an incomplete implementation, which is to be completed by subclasses \
  implementing the abstract methods. If the class is intended to be used as a base class only (not to be \
  instantiated directly) a protected constructor can be provided to prevent direct instantiation.

java.best.practices.AvoidReassigningCatchVariables.rule.msg=Avoid Reassigning Catch Variables
java.best.practices.AvoidReassigningCatchVariablesRule.violation.msg=Avoid Reassigning Catch Variables ''%s''
java.best.practices.AvoidReassigningCatchVariables.rule.desc=Reassigning exception variables caught in a catch \
  statement should be avoided because of:1) If it is needed, multi catch can be easily added and code will still \
  compile.2) Following the principle of least surprise we want to make sure that a variable caught in a catch \
  statement is always the one thrown in a try block.

java.best.practices.AvoidReassigningLoopVariablesRule.rule.msg=Avoid Reassigning Loop Variables
java.best.practices.AvoidReassigningLoopVariablesRule.violation.msg=Avoid Reassigning Loop Variables ''%s''
java.best.practices.AvoidReassigningLoopVariablesRule.rule.desc=Reassigning loop variables can lead to hard-to-find \
  bugs. Prevent or limit how these variables can be changed.

java.best.practices.AvoidReassigningParametersRule.rule.msg=Avoid Reassigning Parameters
java.best.practices.AvoidReassigningParametersRule.violation.msg=Avoid Reassigning Parameters ''%s''
java.best.practices.AvoidReassigningParametersRule.rule.desc=Reassigning values to incoming parameters of a method \
  or constructor is not recommended, as this can make the code more difficult to understand. The code is often read \
  with the assumption that parameter values don’t change and an assignment violates therefore the principle of least \
  astonishment. This is especially a problem if the parameter is documented e.g. in the method’s javadoc and the \
  new content differs from the original documented content.Use temporary local variables instead. This allows you  to\
  assign a new name, which makes the code better understandable.

java.best.practices.AvoidStringBufferFieldRule.rule.msg=Avoid StringBuffer Field
java.best.practices.AvoidStringBufferFieldRule.violation.msg=Avoid %s Field
java.best.practices.AvoidStringBufferFieldRule.rule.desc=StringBuffers/StringBuilders can grow considerably, and so \
  may become a source of memory leaks if held within objects with long lifetimes.

java.best.practices.ConstantInterfaceRule.rule.msg=Avoid Constant Interface
java.best.practices.ConstantInterfaceRule.violation.msg=Avoid Constant Interface
java.best.practices.ConstantInterfaceRule.rule.desc=Using constants in interfaces is a bad practice. Interfaces \
  define types, constants are implementation details better placed in classes or enums.See Effective Java’s ‘Use \
  interfaces only to define types’.

java.best.practices.DefaultLabelNotLastInSwitchStmtRule.rule.msg=Default Label Not Last In Switch Statement
java.best.practices.DefaultLabelNotLastInSwitchStmtRule.violation.msg=Default Label Not Last In Switch Statement
java.best.practices.DefaultLabelNotLastInSwitchStmtRule.rule.desc=By convention, the default label should be the last label in a switch statement.

java.best.practices.DoubleBraceInitializationRule.rule.msg=Avoid Double Brace Initialization
java.best.practices.DoubleBraceInitializationRule.violation.msg=Avoid Double Brace Initialization
java.best.practices.DoubleBraceInitializationRule.rule.desc=Double brace initialisation is a pattern to initialise \
  eg collections concisely. But it implicitly generates a new .class file, and the object holds a strong reference \
  to the enclosing object. For those reasons, it is preferable to initialize the object normally, even though it’s \
  verbose(use exceptions in methods starting with test or ending with Test/Tests/TestCase).

java.best.practices.ForLoopVariableCountRule.rule.msg=For Loop Variable Count
java.best.practices.ForLoopVariableCountRule.violation.msg=For Loop Variable Count
java.best.practices.ForLoopVariableCountRule.rule.desc=Having a lot of control variables in a ‘for’ loop makes it \
  harder to see what range of values the loop iterates over. By default this rule allows a regular ‘for’ loop with only one variable.

java.best.practices.JUnitTestsShouldIncludeAssertRule.rule.msg=JUnit Tests Should Include Assert
java.best.practices.JUnitTestsShouldIncludeAssertRule.violation.msg=JUnit Tests Should Include Assert
java.best.practices.JUnitTestsShouldIncludeAssertRule.rule.desc=JUnit tests should include at least one assertion. \
  This makes the tests more robust, and using assert with messages provide the developer a clearer idea of what the test does.

java.best.practices.EqualsAvoidNullRule.rule.msg=Object equals/equalsIgnoreCase\
   It is easy to throw NPE, so you should use a constant or an object that is sure to have a value to call
java.best.practices.EqualsAvoidNullRule.violation.msg=Object equals/equalsIgnoreCase\
   It is easy to throw NPE, so you should use a constant or an object that is sure to have a value to call
java.best.practices.EqualsAvoidNullRule.rule.desc=Put constant or valued objects first in all Object \
  comparisons, avoiding NPE if the second argument is null.You can also use Apache's StringUtils.equals/equalsIgnoreCase or Objects.equals methods

java.best.practices.MethodReturnsInternalArrayRule.rule.msg=Avoid Method Returns Internal Array
java.best.practices.MethodReturnsInternalArrayRule.violation.msg=Avoid Method Returns Internal Array ''%s''
java.best.practices.MethodReturnsInternalArrayRule.rule.desc=Exposing internal arrays to the caller violates object\
   encapsulation since elements can be removed or replaced outside of the object that owns it. It is safer to return a copy of the array.

java.best.practices.PrimitiveWrapperInstantiationRule.rule.msg=Primitive Wrapper Instantiation
java.best.practices.PrimitiveWrapperInstantiationRule.violation.msg=Do not use `new %s(...)`, prefer `%s.valueOf(...)`
java.best.practices.PrimitiveWrapperInstantiationRule.Boolean.violation.msg=Do not use `%s`, prefer `%s`
java.best.practices.PrimitiveWrapperInstantiationRule.rule.desc=usages of primitive wrapper constructors. They are \
  deprecated since Java 9 and should not be used. Even before Java 9, they can be replaced with usage of the \
  corresponding static valueOf factory method (which may be automatically inserted by the compiler since Java 1.5). \
  This has the advantage that it may reuse common instances instead of creating a new instance each time.

java.best.practices.UnusedFormalParameterRule.rule.msg=Unused Formal Parameter
java.best.practices.UnusedFormalParameterRule.Method.violation.msg=private method has unused parameter ''%s''
java.best.practices.UnusedFormalParameterRule.Constructor.violation.msg=Constructor has unused parameter ''%s''
java.best.practices.UnusedFormalParameterRule.rule.desc=parameters of private methods and constructors that are not \
  referenced them in the method body.Parameters whose name starts with `ignored` or `unused` are filtered out.

java.best.practices.UnusedLocalVariableRule.rule.msg=Unused Local Variable
java.best.practices.UnusedLocalVariableRule.violation.msg=Avoid unused local variable ''%s''
java.best.practices.UnusedLocalVariableRule.rule.desc=Detects when a local variable is declared and/or assigned, \
  but not used. Variables whose name starts with ignored or unused are filtered out.

java.best.practices.UnusedPrivateFieldRule.rule.msg=Unused Private Field
java.best.practices.UnusedPrivateFieldRule.violation.msg=Avoid unused private field ''%s''
java.best.practices.UnusedPrivateFieldRule.rule.desc=Detects when a private field is declared and/or assigned a value, but not used.

java.best.practices.UnusedPrivateMethodRule.rule.msg=Unused Private Method
java.best.practices.UnusedPrivateMethodRule.violation.msg=Avoid unused private methods ''%s''
java.best.practices.UnusedPrivateMethodRule.rule.desc=Unused Private Method detects when a private method is declared but is unused.

java.best.practices.UseCollectionIsEmptyRule.rule.msg=Use Collection Is Empty
java.best.practices.UseCollectionIsEmptyRule.violation.msg=(size() == 0 or size() != 0 or size() < 0 or size() > 1)\
  It is recommended to use isEmpty() to judge empty
java.best.practices.UseCollectionIsEmptyRule.rule.desc=The isEmpty() method on java.util.Collection is provided to \
  determine if a collection has any elements. Comparing the value of size() to 0 does not convey intent as well as the isEmpty() method.

java.best.practices.UseStandardCharsetsRule.rule.msg=Use StandardCharsets
java.best.practices.UseStandardCharsetsRule.violation.msg=It is recommended to use StandardCharsets
java.best.practices.UseStandardCharsetsRule.rule.desc=StandardCharsets provides constants for common Charset objects, \
  such as UTF-8. Using the constants is less error prone, and can provide a small performance advantage compared to \
  Charset.forName(...) since no scan across the internal Charset caches is needed.

java.best.practices.UnusedAssignmentRule.rule.msg=Unused Assignment
java.best.practices.UnusedAssignmentRule.violation.msg=The value assigned to this variable ''%s'' is never used or \
  always overwritten
java.best.practices.UnusedAssignmentRule.rule.desc=The variable is never read after the assignment, or The assigned \
  value is always overwritten by other assignments before the next read of the variable.The rule doesn't consider \
  assignments to fields except for those of `this` in a constructor,or static fields of the current class in static \
  initializers.

java.best.practices.UseTryWithResourcesRule.rule.msg=Use try-with-resources
java.best.practices.UseTryWithResourcesRule.violation.msg=It is recommended to use try-with-resources
java.best.practices.UseTryWithResourcesRule.rule.desc=try-with-resources statement. This statement ensures that each \
  resource is closed at the end of the statement. It avoids the need of explicitly closing the resources in a \
  finally block. Additionally exceptions are better handled: If an exception occurred both in the try block and \
  finally block, then the exception from the try block was suppressed. With the try-with-resources statement, \
  the exception thrown from the try-block is preserved.

java.code.style.AvoidProtectedFieldInFinalClassRule.rule.msg=Avoid Protected Field In Final Class
java.code.style.AvoidProtectedFieldInFinalClassRule.violation.msg=Avoid Protected Field ''%s'' In Final Class
java.code.style.AvoidProtectedFieldInFinalClassRule.rule.desc=Do not use protected fields in final classes since they \
  cannot be subclassed. Clarify your intent by using private or package access modifiers instead.

java.code.style.AvoidProtectedMethodInFinalClassNotExtendingRule.rule.msg=Avoid Protected Method In Final Class
java.code.style.AvoidProtectedMethodInFinalClassNotExtendingRule.violation.msg=Avoid Protected Method ''%s'' In Final Class
java.code.style.AvoidProtectedMethodInFinalClassNotExtendingRule.rule.desc=Do not use protected methods in most final \
  classes since they cannot be subclassed. This should only be allowed in final classes that extend other classes \
  with protected methods (whose visibility cannot be reduced). Clarify your intent by using private or package access modifiers instead.

java.code.style.BooleanGetMethodNameRule.rule.msg=Boolean Get Method Name
java.code.style.BooleanGetMethodNameRule.violation.msg=Avoid the use of the ‘get’ prefix for boolean methods ''%s''.
java.code.style.BooleanGetMethodNameRule.rule.desc=Methods that return boolean results should be named as predicate \
  statements to denote this. I.e, ‘isReady()’, ‘hasValues()’, ‘canCommit()’, ‘willFail()’, etc. \
  Avoid the use of the ‘get’ prefix for these methods.

java.code.style.ClassNamingConventionsRule.rule.msg=Class Naming Conventions
java.code.style.ClassNamingConventionsRule.violation.msg=The {0} name ''{1}'' doesn''t match ''{2}''
java.code.style.ClassNamingConventionsRule.rule.desc=The class name uses the UpperCamelCase style and must follow the \
  camel case(but the following exceptions: domain model related naming DO / BO / DTO / VO / DAO).the abstract class \
  must start with Abstract or Base,.and the unit test class must start with Test or end with Test / Tests / TestCase.

java.code.style.ControlStatementBracesRule.rule.msg=Control Statement Braces
java.code.style.ControlStatementBracesRule.violation.msg=Control statement must contains braces
java.code.style.ControlStatementBracesRule.rule.desc=Enforce a policy for braces on control statements. \
  It is recommended to use braces on ‘if … else’ statements and loop statements, even contains only one statement. \
  This usually makes the code clearer, and helps prepare the future when you need to add another statement. 

java.code.style.EmptyControlStatementRule.rule.msg=Empty Control Statement
java.code.style.EmptyControlStatementRule.finally.violation.msg=Empty finally clause
java.code.style.EmptyControlStatementRule.synchronized.violation.msg=Empty synchronized statement
java.code.style.EmptyControlStatementRule.switch.violation.msg=Empty switch statement
java.code.style.EmptyControlStatementRule.block.violation.msg=Empty block
java.code.style.EmptyControlStatementRule.if.violation.msg=Empty if statement
java.code.style.EmptyControlStatementRule.else.violation.msg=Empty else statement
java.code.style.EmptyControlStatementRule.while.violation.msg=Empty while statement
java.code.style.EmptyControlStatementRule.for.violation.msg=Empty for statement
java.code.style.EmptyControlStatementRule.do.violation.msg=Empty do..while statement
java.code.style.EmptyControlStatementRule.initializer.violation.msg=Empty initializer statement
java.code.style.EmptyControlStatementRule.try.violation.msg=Empty try body
java.code.style.EmptyControlStatementRule.rule.desc=control statements whose body is empty, as well as empty initializers.

java.code.style.EmptyMethodInAbstractClassShouldBeAbstractRule.rule.msg=Empty Method In Abstract Class Should Be Abstract
java.code.style.EmptyMethodInAbstractClassShouldBeAbstractRule.violation.msg=An empty method in an abstract class should be abstract instead
java.code.style.EmptyMethodInAbstractClassShouldBeAbstractRule.rule.desc=Empty or auto-generated methods in an abstract \
  class should be tagged as abstract. This helps to remove their inapproprate usage by developers who should be \
  implementing their own versions in the concrete subclasses.

java.code.style.FieldNamingConventionsRule.rule.msg=Field Naming Conventions
java.code.style.FieldNamingConventionsRule.violation.msg=The %s name ''%s'' doesn''t match ''%s''
java.code.style.FieldNamingConventionsRule.rule.desc=field naming convention ALL_UPPER style.

java.code.style.FormalParameterNamingConventionsRule.rule.msg=Formal Parameter Naming Conventions
java.code.style.FormalParameterNamingConventionsRule.violation.msg=The %s name ''%s'' doesn''t match ''%s''
java.code.style.FormalParameterNamingConventionsRule.rule.desc=formal parameter convention CamelCase style.

java.code.style.GenericsNamingRule.rule.msg=Generics Naming Conventions
java.code.style.GenericsNamingRule.violation.msg=It is recommended to use uppercase letters for generic naming.
java.code.style.GenericsNamingRule.rule.desc=It is recommended to use uppercase letters for generic naming.

java.code.style.LinguisticNamingRule.rule.msg=Linguistic Naming
java.code.style.LinguisticNamingRule.TransformMethods.violation.msg=Linguistics Antipattern - The transform method \
  ''%s'' should not return void linguistically
java.code.style.LinguisticNamingRule.Getters.violation.msg=Linguistics Antipattern - The getter ''%s'' should not \
  return void linguistically
java.code.style.LinguisticNamingRule.Setters.violation.msg=Linguistics Antipattern - The setter ''%s'' should not \
  return any type except void linguistically
java.code.style.LinguisticNamingRule.BooleanMethods.violation.msg=Linguistics Antipattern - The method ''%s'' \
  indicates linguistically it returns a boolean, but it returns ''%s''
java.code.style.LinguisticNamingRule.Field.violation.msg=Linguistics Antipattern - The field ''%s'' indicates \
  linguistically it is a boolean, but it is ''%s''
java.code.style.LinguisticNamingRule.Variable.violation.msg=Linguistics Antipattern - The variable ''%s'' indicates \
  linguistically it is a boolean, but it is ''%s''
java.code.style.LinguisticNamingRule.rule.desc=This rule finds Linguistic Naming Antipatterns. It checks for fields, \
  that are named, as if they should be boolean but have a different type. It also checks for methods, that according \
  to their name, should return a boolean, but don’t. Further, it checks, that getters return something and setters won’t. 

java.code.style.LocalVariableCouldBeFinalRule.rule.msg=Local Variable Could Be Final
java.code.style.LocalVariableCouldBeFinalRule.violation.msg=Local variable ''%s'' could be declared final
java.code.style.LocalVariableCouldBeFinalRule.rule.desc=A local variable assigned only once can be declared final.

java.code.style.LocalVariableNamingConventionsRule.rule.msg=Local Variable Naming Conventions
java.code.style.LocalVariableNamingConventionsRule.violation.msg=The %s name ''%s'' doesn''t match ''%s''
java.code.style.LocalVariableNamingConventionsRule.rule.desc=By default local variable uses the standard Java naming \
  convention (Camel case).

java.code.style.LongVariableRule.rule.msg=Long Variable
java.code.style.LongVariableRule.violation.msg=Avoid excessively long variable names like ''%s''
java.code.style.LongVariableRule.rule.desc=Fields, formal arguments, or local variable names that are too long can \
  make the code difficult to follow.

java.code.style.MethodNamingConventionsRule.rule.msg=Method Naming Conventions
java.code.style.MethodNamingConventionsRule.violation.msg=The %s name ''%s'' doesn''t match ''%s''
java.code.style.MethodNamingConventionsRule.rule.desc=By default method uses the standard Java naming convention \
  (Camel case).

java.code.style.PackageCaseRule.rule.msg=Package Case
java.code.style.PackageCaseRule.violation.msg=package ''%s'' naming contains uppercase characters.
java.code.style.PackageCaseRule.rule.desc=Detects when a package definition contains uppercase characters.

java.code.style.PrematureDeclarationRule.rule.msg=Premature Declaration
java.code.style.PrematureDeclarationRule.violation.msg=Avoid declaring a variable ''%s''if it is unreferenced before a \
  possible exit point.
java.code.style.PrematureDeclarationRule.rule.desc=Checks for variables that are defined before they might be used. \
  A reference is deemed to be premature if it is created right before a block of code that doesn’t use it that also \
  has the ability to return or throw an exception.

java.code.style.UnnecessaryCastRule.rule.msg=Unnecessary Cast
java.code.style.UnnecessaryCastRule.violation.msg=Avoid unnecessary casts ''%s''
java.code.style.UnnecessaryCastRule.rule.desc=This rule detects when a cast is unnecessary while accessing collection elements. 

java.code.style.UnnecessaryLocalBeforeReturnRule.rule.msg=Unnecessary Local Before Return
java.code.style.UnnecessaryLocalBeforeReturnRule.violation.msg=Avoid the creation of unnecessary local variable ''%s''.
java.code.style.UnnecessaryLocalBeforeReturnRule.rule.desc=Avoid the creation of unnecessary local variables.

java.code.style.UnnecessaryConstructorRule.rule.msg=Unnecessary Constructor
java.code.style.UnnecessaryConstructorRule.violation.msg=Avoid unnecessary constructors - the compiler will generate these for you
java.code.style.UnnecessaryConstructorRule.rule.desc=This rule detects when a constructor is not necessary; i.e., \
  when there is only one constructor and the constructor is identical to the default constructor. The default \
  constructor should has same access modifier as the declaring class.

java.code.style.UnnecessaryModifierRule.rule.msg=Unnecessary Modifier
java.code.style.UnnecessaryModifierRule.violation.msg=Unnecessary Modifier ''%s'' on %s ''%s''
java.code.style.UnnecessaryModifierRule.rule.desc=Fields in interfaces and annotations are automatically \
  `public static final`, and methods are `public abstract`. Classes, interfaces or annotations nested in an interface \
  or annotation are automatically `public static`(all nested interfaces and annotations are automatically static). \
  Nested enums are automatically `static`.For historical reasons, modifiers which are implied by the context are \
  accepted by the compiler, but are superfluous.

java.design.AvoidDeeplyNestedIfStmtsRule.rule.msg=Avoid Deeply Nested If Statements
java.design.AvoidDeeplyNestedIfStmtsRule.violation.msg=avoid deeply nested if statements
java.design.AvoidDeeplyNestedIfStmtsRule.rule.desc=Avoid creating deeply nested if-then statements since they are \
  harder to read and error-prone to maintain.

java.design.AvoidRethrowingExceptionRule.rule.msg=Avoid Rethrowing Exception
java.design.AvoidRethrowingExceptionRule.violation.msg=avoid rethrowing exception
java.design.AvoidRethrowingExceptionRule.rule.desc=Catch blocks that merely rethrow a caught exception only add to \
  code size and runtime complexity.

java.design.AvoidThrowingNewInstanceOfSameExceptionRule.rule.msg=Avoid Throwing New Instance Of Same Exception
java.design.AvoidThrowingNewInstanceOfSameExceptionRule.violation.msg=Avoid Throwing New Instance Of Same Exception.
java.design.AvoidThrowingNewInstanceOfSameExceptionRule.rule.desc=Catch blocks that merely rethrow a caught exception \
  wrapped inside a new instance of the same type only add to code size and runtime complexity.

java.design.AvoidThrowingNullPointerExceptionRule.rule.msg=Avoid Throwing NullPointerException
java.design.AvoidThrowingNullPointerExceptionRule.violation.msg=Avoid Throwing NullPointerException
java.design.AvoidThrowingNullPointerExceptionRule.rule.desc=Avoid throwing NullPointerExceptions manually. These are \
  confusing because most people will assume that the virtual machine threw it. To avoid a method being called with \
  a null parameter, you may consider using an IllegalArgumentException instead, making it clearly seen as a \
  programmer-initiated exception.

java.design.ClassWithOnlyPrivateConstructorsShouldBeFinalRule.rule.msg=Class With Only Private Constructors Should Be Final
java.design.ClassWithOnlyPrivateConstructorsShouldBeFinalRule.violation.msg=Class ''%s'' With Only Private \
  Constructors Should Be Final
java.design.ClassWithOnlyPrivateConstructorsShouldBeFinalRule.rule.desc=A class with only private constructors should \
  be final, unless the private constructor is invoked by an inner class.

java.design.CognitiveComplexityRule.rule.msg=Cognitive Complexity
java.design.CognitiveComplexityRule.Method.violation.msg=The method ''%s'' has a cognitive complexity of %s, current \
  threshold is %s
java.design.CognitiveComplexityRule.Constructor.violation.msg=The constructor ''%s'' has a cognitive complexity of \
  %s, current threshold is %s
java.design.CognitiveComplexityRule.rule.desc=Methods that are highly complex are difficult to read and more costly \
  to maintain. If you include too much decisional logic within a single method, you make its behavior hard to \
  understand and more difficult to modify.Information about Cognitive complexity can be found in the original \
  paper here: https://www.sonarsource.com/docs/CognitiveComplexity.pdf

java.design.CollapsibleIfStatementsRule.rule.msg=Collapsible If Statements
java.design.CollapsibleIfStatementsRule.violation.msg=Collapsible If Statements
java.design.CollapsibleIfStatementsRule.rule.desc=Sometimes two consecutive ‘if’ statements can be consolidated by \
  separating their conditions with a boolean short-circuit operator.

java.design.CouplingBetweenObjectsRule.rule.msg=Coupling Between Objects
java.design.CouplingBetweenObjectsRule.violation.msg=The coupling degree of the object is high, the current \
  coupling degree is %s, exceeds the threshold value %s.
java.design.CouplingBetweenObjectsRule.rule.desc=counts the number of unique attributes, local variables, and return \
  types within an object. A number higher than the specified threshold can indicate a high degree of coupling.

java.design.FinalFieldCouldBeStaticRule.rule.msg=Final Field Could Be Static
java.design.FinalFieldCouldBeStaticRule.violation.msg=Final Field ''%s'' Could Be Set Static
java.design.FinalFieldCouldBeStaticRule.rule.desc=If a final field is assigned to a compile-time constant, \
  it could be made static, thus saving overhead in each object at runtime.

java.design.ImmutableFieldRule.rule.msg=Immutable Field
java.design.ImmutableFieldRule.violation.msg=Private field ''%s'' could be made final; it is only initialized \
  in the declaration or constructor.
java.design.ImmutableFieldRule.rule.desc=Identifies private fields whose values never change once object initialization \
  ends either in the declaration of the field or by a constructor. This helps in converting existing classes to becoming \
  immutable ones. Note that this rule does not enforce referenced object to be immutable itself. A class can still be \
  mutable, even if all its member fields are declared final. This is referred to as shallow immutability. For more \
  information on mutability, see Effective Java, 3rd Edition, Item 17: Minimize mutability.

java.design.LogicInversionRule.rule.msg=Logic Inversion
java.design.LogicInversionRule.violation.msg=Use opposite operator instead of negating the whole expression with a \
  logic complement operator.
java.design.LogicInversionRule.rule.desc=Use opposite operator instead of negating the whole expression with a \
  logic complement operator.

java.design.MutableStaticStateRule.rule.msg=Mutable Static State
java.design.MutableStaticStateRule.violation.msg=Non-private static fields should be made constants (or immutable \
  references) by declaring them final.
java.design.MutableStaticStateRule.rule.desc=Non-private non-final static fields break encapsulation and can lead to \
  hard to find bugs, since these fields can be modified from anywhere within the program. Callers can trivially access \
  and modify non-private non-final static fields. Neither accesses nor modifications can be guarded against, and newly \
  set values cannot be validated.

java.design.NcssCountRule.rule.msg=Ncss Count
java.design.NcssCountRule.Class.violation.msg=The %s ''%s'' has a NCSS line count of %s (Highest = %s),Exceeded the \
  threshold of %s.
java.design.NcssCountRule.Method.violation.msg=The method ''%s'' has a NCSS line count of %s,Exceeded the \
  threshold of %s.
java.design.NcssCountRule.Constructor.violation.msg=The constructor ''%s'' has a NCSS line count of %s,Exceeded the \
  threshold of %s.
java.design.NcssCountRule.rule.desc=This rule uses the NCSS (Non-Commenting Source Statements) metric to determine \
  the number of lines of code in a class, method or constructor. If the number of lines of code of a class, \
  method or constructor exceeds the specified threshold, it is generally considered that the class, \
  method or constructor needs to be refactored to make the logic of the code clearer and more reasonable.\
  NCSS ignores comments, blank lines, and only counts actual statements. For more details on the calculation, \
  see the documentation of the：https://docs.pmd-code.org/pmd-doc-6.55.0/pmd_java_metrics_index\
  .html#non-commenting-source-statements-ncss

java.design.NPathComplexityRule.rule.msg=NPath Complexity
java.design.NPathComplexityRule.Method.violation.msg=The method ''%s'' has an NPath complexity of %s, current \
  threshold is %s.
java.design.NPathComplexityRule.Constructor.violation.msg=The constructor ''%s'' has an NPath complexity of %s, current \
  threshold is %s.
java.design.NPathComplexityRule.rule.desc=The NPath complexity of a method is the number of acyclic \
  execution paths through that method. NPath counts the number of full paths from the beginning to the end of the \
  block of the method. That metric grows exponentially, as it multiplies the complexity of statements in the same block.\
   For more details on the calculation, see the documentation of the：\
  https://docs.pmd-code.org/pmd-doc-6.55.0/pmd_java_metrics_index.html#npath-complexity-npath

java.design.SimplifiedTernaryRule.rule.msg=Simplified Ternary
java.design.SimplifiedTernaryRule.violation.msg=condition ? true : false simplifies to return condition.
java.design.SimplifiedTernaryRule.rule.desc=condition ? true : false simplifies to return condition.

java.design.SimplifyBooleanExpressionsRule.rule.msg=Simplify Boolean Expressions
java.design.SimplifyBooleanExpressionsRule.violation.msg=Avoid unnecessary comparisons in boolean expressions
java.design.SimplifyBooleanExpressionsRule.rule.desc=Avoid unnecessary comparisons in boolean expressions, \
  they serve no purpose and impacts readability.

java.design.SimplifyBooleanReturnsRule.rule.msg=Simplify Boolean Returns
java.design.SimplifyBooleanReturnsRule.violation.msg=Avoid unnecessary if-then-else statements when returning booleans
java.design.SimplifyBooleanReturnsRule.rule.desc=Avoid unnecessary if-then-else statements when returning a boolean. \
  The result of the conditional test can be returned instead.

java.design.SimplifyConditionalRule.rule.msg=Simplify Conditional
java.design.SimplifyConditionalRule.violation.msg=No need to check for null before an instanceof
java.design.SimplifyConditionalRule.rule.desc=No need to check for null before an instanceof; the instanceof keyword \
  returns false when given a null argument.

java.design.SingularFieldRule.rule.msg=Singular Field
java.design.SingularFieldRule.violation.msg=Perhaps ''%s'' could be replaced by a local variable.
java.design.SingularFieldRule.rule.desc=Fields whose scopes are limited to just single methods do not rely on the \
  containing object to provide them to other methods. They may be better implemented as local variables within those \
  methods(lombok related Annotation has been set to ignore).

java.design.SwitchDensityRule.rule.msg=Switch Density
java.design.SwitchDensityRule.violation.msg=A high ratio of statements to labels in a switch statement.  Consider refactoring.
java.design.SwitchDensityRule.rule.desc=A high ratio of statements to labels in a switch statement implies that the \
  switch statement is overloaded.  Consider moving the statements into new methods or creating subclasses based on \
  the switch variable.

java.design.TooManyFieldsRule.rule.msg=Too Many Fields
java.design.TooManyFieldsRule.violation.msg=Too Many Fields，Current Threshold is %s。
java.design.TooManyFieldsRule.rule.desc=Classes that have too many fields can become unwieldy and could be redesigned \
  to have fewer fields, possibly through grouping related fields in new objects.

java.design.TooManyMethodsRule.rule.msg=Too Many Methods
java.design.TooManyMethodsRule.violation.msg=This class has too many methods, consider refactoring it.
java.design.TooManyMethodsRule.rule.desc=A class with too many methods is probably a good suspect for refactoring, \
  in order to reduce its complexity and find a way to have more fine grained objects.

java.design.UselessOverridingMethodRule.rule.msg=Useless Overriding Method
java.design.UselessOverridingMethodRule.violation.msg=Overriding method merely calls super
java.design.UselessOverridingMethodRule.rule.desc=The overriding method merely calls the same method defined in a superclass.

java.design.UseObjectForClearerAPIRule.rule.msg=Use Object For Clearer API
java.design.UseObjectForClearerAPIRule.violation.msg=Rather than using a lot of String arguments, consider using a \
  container object for those values.
java.design.UseObjectForClearerAPIRule.rule.desc=When you write a public method, you should be thinking in terms of \
  an API. If your method is public, it means other class will use it, therefore, you want (or need) to offer a \
  comprehensive and evolutive API. If you pass a lot of information as a simple series of Strings, you may think of \
  using an Object to represent all those information. You’ll get a simpler API (such as doWork(Workload workload), \
  rather than a tedious series of Strings) and more importantly, if you need at some point to pass extra data, \
  you’ll be able to do so by simply modifying or extending Workload without any modification to your API.

java.design.ExcessiveParameterListRule.rule.msg=Excessive Parameter List
java.design.ExcessiveParameterListRule.violation.msg=Avoid long parameter lists.current threshold is ten.
java.design.ExcessiveParameterListRule.rule.desc=Methods with numerous parameters are a challenge to maintain, \
  especially if most of them share the same datatype. These situations usually denote the need for new objects to \
  wrap the numerous parameters.

java.design.ExcessivePublicCountRule.rule.msg=Excessive Public Count
java.design.ExcessivePublicCountRule.violation.msg=This class has a bunch of public methods and attributes.\
  current threshold is forty-five.
java.design.ExcessivePublicCountRule.rule.desc=Classes with large numbers of public methods and attributes require \
  disproportionate testing efforts since combinational side effects grow rapidly and increase risk. Refactoring these\
   classes into smaller ones not only increases testability and reliability.

java.documentation.CommentContentRule.rule.msg=Comment Content
java.documentation.CommentContentRule.violation.msg=Do not include discriminatory language in comments.
java.documentation.CommentContentRule.rule.desc=Do not include discriminatory language in comments.

java.documentation.CommentRequiredRule.rule.msg=Comment Required
java.documentation.CommentRequiredRule.violation.msg=Need to include ''%s'' comments
java.documentation.CommentRequiredRule.rule.desc=Public, protected methods and classes, fields, and enumerations \
  need to include comments

java.multithreading.AvoidThreadGroupRule.rule.msg=Avoid Thread Group
java.multithreading.AvoidThreadGroupRule.violation.msg=Avoid use java.lang.ThreadGroup,it is not thread safe.
java.multithreading.AvoidThreadGroupRule.rule.desc=Avoid using java.lang.ThreadGroup; although it is intended to be \
  used in a threaded environment it contains methods that are not thread-safe.

java.multithreading.DoubleCheckedLockingRule.rule.msg=Double Checked Locking
java.multithreading.DoubleCheckedLockingRule.violation.msg=Double Check locking in Java is not thread-safe, and the \
  volatile keyword needs to be added to prohibit instruction rearrangement.
java.multithreading.DoubleCheckedLockingRule.rule.desc=Double Check locking in Java is not thread-safe, and the \
  volatile keyword needs to be added to prohibit instruction rearrangement.

java.multithreading.UnSynchronizedStaticFormatterRule.rule.msg=UnSynchronized Static Formatter
java.multithreading.UnSynchronizedStaticFormatterRule.violation.msg=Static Formatter objects should be accessed in \
  a synchronized manner
java.multithreading.UnSynchronizedStaticFormatterRule.rule.desc=If multiple threads must access a static formatter, \
  the formatter must be synchronized on block level.

java.performance.AddEmptyStringRule.rule.msg=Avoid Add Empty String
java.performance.AddEmptyStringRule.violation.msg=Avoid concatenating literals by adding empty strings
java.performance.AddEmptyStringRule.rule.desc=The conversion of literals to strings by concatenating them with empty \
  strings is inefficient. It is much better to use one of the type-specific `toString()` methods instead or `String.valueOf()`.

java.performance.AppendCharacterWithCharRule.rule.msg=Append Character With CharR
java.performance.AppendCharacterWithCharRule.violation.msg=Avoid appending characters as strings in StringBuffer.append.
java.performance.AppendCharacterWithCharRule.rule.desc=Avoid concatenating characters as strings in StringBuffer/StringBuilder.append methods.

java.performance.AvoidCalendarDateCreationRule.rule.msg=Avoid Calendar Date Creation
java.performance.AvoidCalendarDateCreationRule.violation.msg=A Calendar is used to create a Date or DateTime, this is expensive.
java.performance.AvoidCalendarDateCreationRule.rule.desc=A Calendar is a heavyweight object and expensive to create.

java.performance.AvoidFileStreamRule.rule.msg=Avoid using FileStream in versions below JDK10
java.performance.AvoidFileStreamRule.violation.msg=Avoid using FileStream in versions below JDK10
java.performance.AvoidFileStreamRule.rule.desc=The FileInputStream and FileOutputStream classes contain a finalizer \
  method that will cause a GC pause. This problem has been fixed in JDK10 version, \
  see:https://bugs.openjdk.org/browse/JDK-8080225.Please note, that the java.nio API does not throw \
  a FileNotFoundException anymore, instead it throws a NoSuchFileException. If your code dealt explicitly \
  with a FileNotFoundException, then this needs to be adjusted. 

java.performance.AvoidInstantiatingObjectsInLoopsRule.rule.msg=Avoid Instantiating Objects In Loops
java.performance.AvoidInstantiatingObjectsInLoopsRule.violation.msg=Avoid instantiating new objects inside loops
java.performance.AvoidInstantiatingObjectsInLoopsRule.rule.desc=New objects created within loops should be checked \
  to see if they can created outside them and reused.

java.performance.BigIntegerInstantiationRule.rule.msg=BigInteger Instantiation
java.performance.BigIntegerInstantiationRule.violation.msg=Don't create instances of already existing BigInteger \
  and BigDecimal (ZERO, ONE, TEN)
java.performance.BigIntegerInstantiationRule.rule.desc=Don't create instances of already existing BigInteger.ZERO, \
  BigInteger.ONE and BigInteger.TEN and BigDecimal.ZERO, BigDecimal.ONE, BigDecimal.TEN

java.performance.ConsecutiveAppendsShouldReuseRule.rule.msg=Consecutive Appends Should Reuse
java.performance.ConsecutiveAppendsShouldReuseRule.violation.msg=StringBuffer (or StringBuilder).append is called \
  consecutively without reusing the target variable.
java.performance.ConsecutiveAppendsShouldReuseRule.rule.desc=Consecutive calls to StringBuffer/StringBuilder .append \
  should be chained, reusing the target object. This can improve the performance by producing a smaller bytecode, \
  reducing overhead and improving inlining. A complete analysis can be found：\
  https://github.com/pmd/pmd/issues/202#issuecomment-274349067

java.performance.ConsecutiveLiteralAppendsRule.rule.msg=Consecutive Literal Appends
java.performance.ConsecutiveLiteralAppendsRule.violation.msg=StringBuffer (or StringBuilder).append is called %s \
  consecutive times with literals. Use a single append with a single combined String.
java.performance.ConsecutiveLiteralAppendsRule.rule.desc=Consecutively calling StringBuffer/StringBuilder.append(...) \
  with literals should be avoided.Since the literals are constants, they can already be combined into a single String \
  literal and this String can be appended in a single method call.

java.performance.InefficientStringBufferingRule.rule.msg=Inefficient String Buffering
java.performance.InefficientStringBufferingRule.violation.msg=Avoid concatenating nonliterals in a StringBuffer/StringBuilder constructor or append().
java.performance.InefficientStringBufferingRule.rule.desc=Avoid concatenating non-literals in a StringBuffer \
  constructor or append() since intermediate buffers will need to be be created and destroyed by the JVM.

java.performance.InsufficientStringBufferDeclarationRule.rule.msg=Insufficient StringBuffer Declaration
java.performance.InsufficientStringBufferDeclarationRule.violation.msg=%s has been initialized with size %s, but has \
  at least %s characters appended.
java.performance.InsufficientStringBufferDeclarationRule.rule.desc=Failing to pre-size a StringBuffer or \
  StringBuilder properly could cause it to re-size many times during runtime. An empty StringBuffer/StringBuilder \
  constructor initializes the object to 16 characters. This default is assumed if the length of the constructor can \
  not be determined.

java.performance.OptimizableToArrayCallRule.rule.msg=Optimizable To Array Call
java.performance.OptimizableToArrayCallRule.violation.msg=This call to Collection.toArray() may be optimizable
java.performance.OptimizableToArrayCallRule.rule.desc=Calls to a collection's `toArray(E[])` method should specify \
  a target array of zero size. This allows the JVM to optimize the memory allocation and copying as much as possible.

java.performance.RedundantFieldInitializerRule.rule.msg=Redundant Field Initializer
java.performance.RedundantFieldInitializerRule.violation.msg=Avoid using redundant field initializer for ''%s''
java.performance.RedundantFieldInitializerRule.rule.desc=Java will initialize fields with known default values so any \
  explicit initialization of those same defaults is redundant and results in a larger class file (approximately three\
   additional bytecode instructions per field).

java.performance.StringInstantiationRule.rule.msg=String Instantiation
java.performance.StringInstantiationRule.violation.msg=Avoid instantiating String objects; this is usually unnecessary.
java.performance.StringInstantiationRule.rule.desc=Avoid instantiating String objects; this is usually unnecessary \
  since they are immutable and can be safely shared.

java.performance.StringToStringRule.rule.msg=String To String
java.performance.StringToStringRule.violation.msg=Avoid calling toString() on String objects; this is unnecessary.
java.performance.StringToStringRule.rule.desc=Avoid calling toString() on objects already known to be string instances; this is unnecessary.

java.performance.TooFewBranchesForASwitchStatementRule.rule.msg=Too Few Branches For A Switch Statement
java.performance.TooFewBranchesForASwitchStatementRule.violation.msg=A switch with less than three branches is \
  inefficient, use a 'if statement' instead.
java.performance.TooFewBranchesForASwitchStatementRule.rule.desc=Switch statements are intended to be used to support \
  complex branching behaviour. Using a switch for only a few cases is ill-advised, since switches are not as easy to \
  understand as if-else statements. In these cases use the if-else statement to increase code readability.

java.performance.UseIndexOfCharRule.rule.msg=Use Index Of Char
java.performance.UseIndexOfCharRule.violation.msg=String.indexOf(char) is faster than String.indexOf(String).
java.performance.UseIndexOfCharRule.rule.desc=Use String.indexOf(char) when checking for the index of a single character; it executes faster.

java.performance.UseIOStreamsWithApacheCommonsFileItemRule.rule.msg=Use IO Streams With Apache Commons File Item
java.performance.UseIOStreamsWithApacheCommonsFileItemRule.violation.msg=Avoid memory intensive FileItem.get() or FileItem.getString()
java.performance.UseIOStreamsWithApacheCommonsFileItemRule.rule.desc=Use of FileItem.get() and FileItem.getString() \
  could exhaust memory since they load the entire file into memory.Solution: Use FileItem.getInputStream() and \
  buffering.

java.performance.UselessStringValueOfRule.rule.msg=Useless String ValueOf
java.performance.UselessStringValueOfRule.violation.msg=No need to call String.valueOf to append to a string.
java.performance.UselessStringValueOfRule.rule.desc=No need to call String.valueOf to append to a string; just use the valueOf() argument directly.

java.performance.UseStringBufferForStringAppendsRule.rule.msg=Use StringBuffer For String Appends
java.performance.UseStringBufferForStringAppendsRule.violation.msg=Prefer StringBuilder (non-synchronized) or \
  StringBuffer (synchronized) over += for concatenating strings
java.performance.UseStringBufferForStringAppendsRule.rule.desc=The use of the '+=' operator for appending strings \
  causes the JVM to create and use an internal StringBuffer. If a non-trivial number of these concatenations are \
  being used then the explicit use of a StringBuilder or threadsafe StringBuffer is recommended to avoid this.

java.performance.UseStringBufferLengthRule.rule.msg=Use StringBuffer Length
java.performance.UseStringBufferLengthRule.violation.msg=This is an inefficient use of StringBuffer.toString; call StringBuffer.length instead.
java.performance.UseStringBufferLengthRule.rule.desc=Use StringBuffer.length() to determine StringBuffer length rather \
  than using StringBuffer.toString().equals("") or StringBuffer.toString().length()

java.errorprone.AssignmentInOperandRule.rule.msg=Assignment In Operand
java.errorprone.AssignmentInOperandRule.violation.msg=Avoid assignments in operands
java.errorprone.AssignmentInOperandRule.rule.desc=Avoid assignments in operands; this can make code more complicated and harder to read.

java.errorprone.AssignmentToNonFinalStaticRule.rule.msg=Assignment To Non Final Static
java.errorprone.AssignmentToNonFinalStaticRule.violation.msg=Possible unsafe assignment to a non-final static field \
  ''%s'' in a constructor.
java.errorprone.AssignmentToNonFinalStaticRule.rule.desc=Identifies a possible unsafe usage of a static field.

java.errorprone.AvoidDecimalLiteralsInBigDecimalConstructorRule.rule.msg=Avoid Decimal Literals In BigDecimal \
  Constructor
java.errorprone.AvoidDecimalLiteralsInBigDecimalConstructorRule.violation.msg=Avoid creating BigDecimal with a \
  decimal (float/double) literal. Use a String literal
java.errorprone.AvoidDecimalLiteralsInBigDecimalConstructorRule.rule.desc=One might assume that the result of \
  "new BigDecimal(0.1)" is exactly equal to 0.1, but it is actually equal to \
  .1000000000000000055511151231257827021181583404541015625.This is because 0.1 cannot be represented exactly as \
  a double (or as a binary fraction of any finite length). 

java.errorprone.AvoidDuplicateLiteralsRule.rule.msg=Avoid Duplicate Literals
java.errorprone.AvoidDuplicateLiteralsRule.violation.msg=The String literal %s appears %s times in this file; the \
  first occurrence is on line %s
java.errorprone.AvoidDuplicateLiteralsRule.rule.desc=Code containing duplicate String literals can usually be \
  improved by declaring the String as a constant field.

java.errorprone.AvoidFieldNameMatchingMethodNameRule.rule.msg=Avoid Field Name Matching Method Name
java.errorprone.AvoidFieldNameMatchingMethodNameRule.violation.msg=Field ''%s'' has the same name as a method
java.errorprone.AvoidFieldNameMatchingMethodNameRule.rule.desc=It can be confusing to have a field name with the same\
   name as a method. While this is permitted.

java.errorprone.AvoidFieldNameMatchingTypeNameRule.rule.msg=Avoid Field Name Matching Type Name
java.errorprone.AvoidFieldNameMatchingTypeNameRule.violation.msg=It is somewhat confusing to have a field name \
  ''%s'' matching the declaring class name
java.errorprone.AvoidFieldNameMatchingTypeNameRule.rule.desc=It is somewhat confusing to have a field name matching \
  the declaring type name.

java.errorprone.AvoidInstanceofChecksInCatchClauseRule.rule.msg=Avoid Instance of Checks In Catch Clause
java.errorprone.AvoidInstanceofChecksInCatchClauseRule.violation.msg=Each caught exception type should be handled in its own catch clause.
java.errorprone.AvoidInstanceofChecksInCatchClauseRule.rule.desc=Each caught exception type should be handled in its own catch clause.

java.errorprone.AvoidLiteralsInIfConditionRule.rule.msg=Avoid Literals In If Condition
java.errorprone.AvoidLiteralsInIfConditionRule.violation.msg=Avoid using Literals in Conditional Statements.
java.errorprone.AvoidLiteralsInIfConditionRule.rule.desc=Avoid using hard-coded literals in conditional statements. \
  By declaring them as static variables or private members with descriptive names maintainability is enhanced. 

java.errorprone.AvoidMultipleUnaryOperatorsRule.rule.msg=Avoid Multiple Unary Operators
java.errorprone.AvoidMultipleUnaryOperatorsRule.violation.msg=Using multiple unary operators may be a bug, and/or is confusing.
java.errorprone.AvoidMultipleUnaryOperatorsRule.rule.desc=The use of multiple unary operators may be problematic, \
  and/or confusing.Ensure that the intended usage is not a bug, or consider simplifying the expression.

java.errorprone.ClassCastExceptionWithToArrayRule.rule.msg=ClassCastException With To Array
java.errorprone.ClassCastExceptionWithToArrayRule.violation.msg=This usage of the Collection.toArray() method will \
  throw a ClassCastException.
java.errorprone.ClassCastExceptionWithToArrayRule.rule.desc=When deriving an array of a specific class from your \
  Collection, one should provide an array of the same class as the parameter of the toArray() method. Doing otherwise\
   you will will result in a ClassCastException.

java.errorprone.CloneMethodMustBePublicRule.rule.msg=Clone Method Must Be Public
java.errorprone.CloneMethodMustBePublicRule.violation.msg=clone() method must be public if the class implements \
  Cloneable.
java.errorprone.CloneMethodMustBePublicRule.rule.desc=clone() method must be public if the class implements Cloneable.

java.errorprone.CloneMethodReturnTypeMustMatchClassNameRule.rule.msg=Clone Method Return Type Must Match ClassName
java.errorprone.CloneMethodReturnTypeMustMatchClassNameRule.violation.msg=The return type of the clone() method must \
  be the class name when implements Cloneable.
java.errorprone.CloneMethodReturnTypeMustMatchClassNameRule.rule.desc=The return type of the clone() method must be \
  the class name when implements Cloneable.

java.errorprone.CompareObjectsWithEqualsRule.rule.msg=Compare Objects With Equals
java.errorprone.CompareObjectsWithEqualsRule.violation.msg=Use equals() to compare object references.
java.errorprone.CompareObjectsWithEqualsRule.rule.desc=Use equals() to compare object references，avoid use “==” to \
  compare.

java.errorprone.DoNotThrowExceptionInFinallyRule.rule.msg=Do Not Throw Exception In Finally
java.errorprone.DoNotThrowExceptionInFinallyRule.violation.msg=A throw statement in a finally block makes the control flow hard to understand.
java.errorprone.DoNotThrowExceptionInFinallyRule.rule.desc=Throwing exceptions within a 'finally' block is confusing \
  since they may mask other exceptions or code defects.

java.errorprone.EmptyCatchBlockRule.rule.msg=Empty Catch Block
java.errorprone.EmptyCatchBlockRule.violation.msg=Avoid empty catch blocks
java.errorprone.EmptyCatchBlockRule.rule.desc=Avoid catch exceptions but do nothing. Can be configured through the \
  allowExceptionNameRegex attribute to ignore the exception name, the default is ignored and expected.

java.errorprone.ImplicitSwitchFallThroughRule.rule.msg=Implicit Switch Fall Through
java.errorprone.ImplicitSwitchFallThroughRule.violation.msg=A switch statement does not contain a break or return
java.errorprone.ImplicitSwitchFallThroughRule.rule.desc=Switch statements without break or return statements for each \
  case option may indicate problematic behaviour.

java.errorprone.InstantiationToGetClassRule.rule.msg=Instantiation To GetClass
java.errorprone.InstantiationToGetClassRule.violation.msg=Avoid instantiating an object just to call getClass() on it; use the .class public member instead
java.errorprone.InstantiationToGetClassRule.rule.desc=Avoid instantiating an object just to call getClass() on it; use the .class public member instead.

java.errorprone.MethodWithSameNameAsEnclosingClassRule.rule.msg=Method With Same Name As Enclosing Class
java.errorprone.MethodWithSameNameAsEnclosingClassRule.violation.msg=Classes should not have non-constructor methods with the same name as the class
java.errorprone.MethodWithSameNameAsEnclosingClassRule.rule.desc=Non-constructor methods should not have the same name as the enclosing class.

java.errorprone.MissingSerialVersionUIDRule.rule.msg=Missing SerialVersionUID
java.errorprone.MissingSerialVersionUIDRule.violation.msg=Classes implementing Serializable should set a serialVersionUID
java.errorprone.MissingSerialVersionUIDRule.rule.desc=Serializable classes should provide a serialVersionUID field.\
  The serialVersionUID field is also needed for abstract base classes. Each individual class in the inheritance chain\
   needs an own serialVersionUID field.

java.errorprone.NonSerializableClassRule.rule.msg=Non Serializable Class
java.errorprone.NonSerializableClassRule.violation.msg=The field ''%s'' of serializable class ''%s'' is of \
  non-serializable type ''%s''.
java.errorprone.NonSerializableClassRule.field.violation.msg=The field ''%s'' should be private static final with \
  type ''%s''.
java.errorprone.NonSerializableClassRule.rule.desc=If a class is marked as `Serializable`, then all fields need to \
  be serializable as well. In order to exclude a field, it can be marked as transient. Static fields are not considered.

java.errorprone.OverrideBothEqualsAndHashcodeRule.rule.msg=Override Both Equals And Hashcode
java.errorprone.OverrideBothEqualsAndHashcodeRule.violation.msg=Ensure you override both equals() and hashCode().
java.errorprone.OverrideBothEqualsAndHashcodeRule.rule.desc=Override both public boolean Object.equals(Object other), \
  and public int Object.hashCode(), or override neither.  Even if you are inheriting a hashCode() from a parent class, \
  consider implementing hashCode and explicitly delegating to your superclass.

java.errorprone.ProperLoggerRule.rule.msg=Proper Logger
java.errorprone.ProperLoggerRule.violation.msg=Logger should be defined private static final and have the correct class.
java.errorprone.ProperLoggerRule.rule.desc=A logger should normally be defined private static final and be associated \
  with the correct class.''private final Log log;'' is also allowed for rare cases where loggers need to be passed \
  around,with the restriction that the logger needs to be passed into the constructor.

java.errorprone.ReturnEmptyCollectionRatherThanNullRule.rule.msg=Return Empty Collection Rather Than Null
java.errorprone.ReturnEmptyCollectionRatherThanNullRule.violation.msg=Return an empty collection rather than ''null''.
java.errorprone.ReturnEmptyCollectionRatherThanNullRule.rule.desc=For any method that returns an collection \
  (such as an array, Collection or Map), it is better to return an empty one rather than a null reference. This \
  removes the need for null checking all results and avoids inadvertent NullPointerExceptions.

java.errorprone.ReturnFromFinallyBlockRule.rule.msg=Return From Finally Block
java.errorprone.ReturnFromFinallyBlockRule.violation.msg==Avoid returning from a finally block.
java.errorprone.ReturnFromFinallyBlockRule.rule.desc=Avoid returning from a finally block, this can discard exceptions.

java.errorprone.UnconditionalIfStatementRule.rule.msg=Unconditional If Statement
java.errorprone.UnconditionalIfStatementRule.violation.msg=Do not use ''if'' statements that are always true or always \
   false.
java.errorprone.UnconditionalIfStatementRule.rule.desc=Do not use ''if'' statements that are always true or always \
   false.

java.customization.StreamExpressionStyleRule.rule.msg=stream expression rule
java.customization.StreamExpressionStyleRule.violation.msg=Each node of a stream expression needs a newline(\
  The first node of a stream expression may or may not be change new line, such as .stream() and .filter() \
  in the following examples. list.stream(), getStreamInfo().filter()), which can make the expression of the stream \
  expression clearer and more intuitive.
java.customization.StreamExpressionStyleRule.rule.desc=Each node of a stream expression needs a newline, which can make \
  the expression of the stream expression clearer and more intuitive.

java.customization.ConditionalTooLongNeedChangeLineRule.rule.msg=The conditional statement is too long and needs to be wrapped
java.customization.ConditionalTooLongNeedChangeLineRule.violation.msg=The conditional statement is too long and needs to be wrapped
java.customization.ConditionalTooLongNeedChangeLineRule.rule.desc=If the length of the conditional statement of the \
  conditional judgment statement exceeds 50 characters a newline is required and the conditional character needs \
  to be change line together.

java.customization.AvoidComplexConditionalRule.rule.msg=Avoid Complex Conditional
java.customization.AvoidComplexConditionalRule.violation.msg=avoid complex conditional.
java.customization.AvoidComplexConditionalRule.rule.desc=Avoid using complex logic expressions in conditional \
  statements, which may confuse other readers.

java.customization.StreamExpressionTooLongRule.rule.msg=Stream Expression Too Long
java.customization.StreamExpressionTooLongRule.violation.msg=If the stream expression exceeds 30 lines, it needs to be split.
java.customization.StreamExpressionTooLongRule.rule.desc=If the stream expression is too long, it will affect the readability \
  and comprehension of the code. If the stream expression exceeds 30 lines, it needs to be split.The number of \
  statistical lines does not include comments.

java.customization.AvoidStreamExpressionInIfStmtsRule.rule.msg=Avoid including stream expression or Optional expression in if statements.
java.customization.AvoidStreamExpressionInIfStmtsRule.violation.msg=Avoid including stream expression or Optional expression in if statements.
java.customization.AvoidStreamExpressionInIfStmtsRule.rule.desc=Avoid including stream expression or Optional expression in if statements.

java.customization.UndefinedMagicConstantRule.rule.msg=Undefined Magic Constant
java.customization.UndefinedMagicConstantRule.violation.msg=avoid magic constant %s.
java.customization.UndefinedMagicConstantRule.rule.desc=Any magic constant (i.e. undefined constants) are not allowed to \
  appear directly in the code.

java.customization.AvoidIfStmtsInSwitchStmtsRule.rule.msg=Avoid if stmts use in switch stmts
java.customization.AvoidIfStmtsInSwitchStmtsRule.violation.msg=Avoid if statements use in switch statements
java.customization.AvoidIfStmtsInSwitchStmtsRule.rule.desc=Both switch and if are conditional judgment statements. \
  Mixing the two may increase the complexity of the code. It is recommended that the if statement in switch can be \
  refactored into a method for use.

java.customization.AvoidStreamExpressionInStreamExpressionRule.rule.msg=Avoid stream expression use in stream expression
java.customization.AvoidStreamExpressionInStreamExpressionRule.violation.msg=It is not recommended to nest the stream \
  expression in the stream expression,which will make the whole stream expression extremely complicated and difficult\
   to understand.
java.customization.AvoidStreamExpressionInStreamExpressionRule.rule.desc=It is not recommended to nest the stream \
  expression in the stream expression,which will make the whole stream expression extremely complicated and difficult\
   to understand.

java.customization.GuardClausesRule.rule.msg=Guard Clauses
java.customization.GuardClausesRule.violation.msg=The guard statement simplifies the flow of the program by logically \
  analyzing the original conditions and prioritizing some key (guard) conditions for judgment.
java.customization.GuardClausesRule.rule.desc=The guard statement simplifies the flow of the program by logically \
  analyzing the original conditions and prioritizing some key (guard) conditions for judgment.\
  For a detailed definition of the guard sentence, see：https://en.wikipedia.org/wiki/Guard_(computer_science)

java.customization.CollectorsToMapUnUseThirdParamRule.rule.msg=Collectors.toMap/toConCurrentMap unUse third parameter
java.customization.CollectorsToMapUnUseThirdParamRule.violation.msg=Collectors.toMap/toConCurrentMap will throw \
  java.lang.IllegalStateException: Duplicate key error if the third parameter is not used and there is a duplicate key
java.customization.CollectorsToMapUnUseThirdParamRule.rule.desc=Collectors.toMap/toConCurrentMap will throw \
  java.lang.IllegalStateException: Duplicate key error if the third parameter is not used and there is a duplicate key

java.customization.AvoidTooManyConditionRule.rule.msg=Avoid Too Many Condition
java.customization.AvoidTooManyConditionRule.violation.msg=Condition number over than threshold %s.
java.customization.AvoidTooManyConditionRule.rule.desc=There are too many conditions, which affects the understanding \
  of the code. The default threshold is 4.

java.customization.AvoidUseComplexStreamExpressionInSetMethodRule.rule.msg=Avoid passing complex stream expressions \
  in  the set method
java.customization.AvoidUseComplexStreamExpressionInSetMethodRule.violation.msg=Avoid passing complex stream expressions \
  in  the set method
java.customization.AvoidUseComplexStreamExpressionInSetMethodRule.rule.desc=Passing complex stream expressions as \
  input  parameters of the set method will increase the complexity of understanding and reading.

java.customization.AvoidUseSimpleDateFormatRule.rule.msg=Avoid Use SimpleDateFormat
java.customization.AvoidUseSimpleDateFormatRule.violation.msg=In the scenario where SimpleDateFormat is a static \
  variable, using the format or parse method is thread-unsafe.
java.customization.AvoidUseSimpleDateFormatRule.rule.desc=In the scenario where SimpleDateFormat is a static \
  variable, using the format or parse method is thread-unsafe.In multi-threaded scenarios it is recommended to use \
  Apache's FastDateFormat.

java.customization.AvoidUseUnSynchronizedFormatRule.rule.msg=Avoid using Format class without Synchronized keyword
java.customization.AvoidUseUnSynchronizedFormatRule.violation.msg=In the scenario where Format is a static \
  variable, using the format,parse etc. method is thread-unsafe.
java.customization.AvoidUseUnSynchronizedFormatRule.rule.desc=In scenarios where DateFormat, SimpleDateFormat,  \
  NumberFormat, and MessageFormat are static member variables, using methods such as format and parse is \
  thread-unsafe.  In multi-threaded scenarios, it is recommended to use non-static member variables. For Date related\
  , you can use Apache's FastDateFormat.
