java.pmd.intellij.plugin.textarea.rule.name=规则名称：
java.pmd.intellij.plugin.textarea.rule.desc=规则说明：
java.pmd.intellij.plugin.textarea.pmd.rule.url=PMD官方Url：
java.pmd.intellij.plugin.textarea.pmd.example=规则举例：

java.best.practices.AbstractClassWithoutAbstractMethod.rule.msg=抽象类没有抽象方法
java.best.practices.AbstractClassWithoutAbstractMethodRule.violation.msg=抽象类%s没有抽象方法
java.best.practices.AbstractClassWithoutAbstractMethodRule.rule.desc=抽象类不包含任何抽象方法。抽象类意味着不完整的实现，\
  该实现将由实现抽象方法的子类来完成。如果该类仅用作基类（不直接实例化），则可以提供受保护的构造函数以防止直接实例化。

java.best.practices.AvoidReassigningCatchVariables.rule.msg=避免重新分配catch的异常变量
java.best.practices.AvoidReassigningCatchVariablesRule.violation.msg=避免重新分配catch的异常变量''%s''
java.best.practices.AvoidReassigningCatchVariables.rule.desc=应避免重新分配catch语句中捕获的异常变量，因为：1) \
  如果需要，可以轻松添加多重catch并且代码仍然可以编译。2) 遵循最小意外原则，我们希望确保catch语句中捕获的变量始终是try块中抛出的变量

java.best.practices.AvoidReassigningLoopVariablesRule.rule.msg=避免重新分配循环变量
java.best.practices.AvoidReassigningLoopVariablesRule.violation.msg=避免重新分配循环变量''%s''
java.best.practices.AvoidReassigningLoopVariablesRule.rule.desc=重新分配循环变量可能会导致难以发现的错误。

java.best.practices.AvoidReassigningParametersRule.rule.msg=避免重新分配参数
java.best.practices.AvoidReassigningParametersRule.violation.msg=避免重新分配参数''%s''
java.best.practices.AvoidReassigningParametersRule.rule.desc=不建议方法或构造函数对传入的参数重新分配值，因为这会使代码更 \
  难以理解。阅读代码时通常假设参数值不会改变，因此赋值违反了最少意外/惊讶原则。请改用临时局部变量。

java.best.practices.AvoidStringBufferFieldRule.rule.msg=避免StringBuffer/StringBuilders字段保存在具有长生命周期的对象中
java.best.practices.AvoidStringBufferFieldRule.violation.msg=避免%s字段保存在具有长生命周期的对象中
java.best.practices.AvoidStringBufferFieldRule.rule.desc=StringBuffers/StringBuilders可以显着增长，因此如果保存在具有长\
  生命周期的对象中，可能会成为内存泄漏的根源

java.best.practices.ConstantInterfaceRule.rule.msg=避免在接口中定义常量
java.best.practices.ConstantInterfaceRule.violation.msg=避免在接口中定义常量
java.best.practices.ConstantInterfaceRule.rule.desc=在接口中使用常量是一种不好的做法。接口定义类型，常量是更好地放置在类\
  或枚举中的实现细节。请参阅Effective Java 的“仅使用接口来定义类型”

java.best.practices.DefaultLabelNotLastInSwitchStmtRule.rule.msg=switch语句最后一个标签应该是default
java.best.practices.DefaultLabelNotLastInSwitchStmtRule.violation.msg=switch语句最后一个标签应该是default
java.best.practices.DefaultLabelNotLastInSwitchStmtRule.rule.desc=按照约定，default标签应该是switch语句中的最后一个标签。

java.best.practices.DoubleBraceInitializationRule.rule.msg=避免用双大括号初始化
java.best.practices.DoubleBraceInitializationRule.violation.msg=避免用双大括号初始化
java.best.practices.DoubleBraceInitializationRule.rule.desc=双括号初始化是一种简洁地初始化例如集合的模式。但它隐式生成一个新的\
  .class文件，并且该对象持有对封闭对象的强引用。出于这些原因，最好正常初始化对象，即使它很冗长(在test开头或Test/Tests/TestCase结尾的方法中使用例外)。

java.best.practices.ForLoopVariableCountRule.rule.msg=For循环变量计数
java.best.practices.ForLoopVariableCountRule.violation.msg=For循环变量计数
java.best.practices.ForLoopVariableCountRule.rule.desc=在“for”循环中包含大量控制变量使得更难看出循环迭代的值范围。默认情况下，仅允许仅包含一个变量的常规“for”循环。

java.best.practices.JUnitTestsShouldIncludeAssertRule.rule.msg=JUnit测试应该包含断言
java.best.practices.JUnitTestsShouldIncludeAssertRule.violation.msg=JUnit测试应该包含断言
java.best.practices.JUnitTestsShouldIncludeAssertRule.rule.desc=JUnit测试应至少包含一个断言。这使得测试更加健壮。

java.best.practices.EqualsAvoidNullRule.rule.msg=Object的equals/equalsIgnoreCase等容易抛空指针异常，应使用常量或确定有值的对象来调用
java.best.practices.EqualsAvoidNullRule.violation.msg=Object的equals/equalsIgnoreCase等容易抛空指针异常，应使用常量或确定有值的对象来调用
java.best.practices.EqualsAvoidNullRule.rule.desc=在所有Object比较中将常量或有值的对象放在第一位，如果第二个参数为null，则可以避免NPE。\
  也可以使用Apache的StringUtils.equals/equalsIgnoreCase或Objects.equals方法

java.best.practices.MethodReturnsInternalArrayRule.rule.msg=避免方法返回内部数组
java.best.practices.MethodReturnsInternalArrayRule.violation.msg=避免方法返回内部数组''%s''
java.best.practices.MethodReturnsInternalArrayRule.rule.desc=将内部数组暴露给调用者违反了对象封装，因为可以在拥有它的对象之外删除或替换元素。返回数组的副本更安全

java.best.practices.PrimitiveWrapperInstantiationRule.rule.msg=原始包装实例化
java.best.practices.PrimitiveWrapperInstantiationRule.violation.msg=不要使用`new %s(...)`, 建议使用`%s.valueOf(...)`
java.best.practices.PrimitiveWrapperInstantiationRule.Boolean.violation.msg=不要使用`%s`, 建议使用`%s`
java.best.practices.PrimitiveWrapperInstantiationRule.rule.desc=原始包装构造函数的用法。它们自Java 9起已被弃用，不应使用。\
  即使在Java 9之前，它们也可以使用相应的静态valueOf工厂方法来替换。这样做的好处是可以重用公共实例，而不是每次都创建一个新实例。

java.best.practices.UnusedFormalParameterRule.rule.msg=未使用的参数
java.best.practices.UnusedFormalParameterRule.Method.violation.msg=私有方法有未使用的参数''%s''
java.best.practices.UnusedFormalParameterRule.Constructor.violation.msg=构造方法有未使用的参数''%s''
java.best.practices.UnusedFormalParameterRule.rule.desc=私有方法和构造函数中有未使用的参数。名称以ignored或unused开头的参数会被过滤掉。

java.best.practices.UnusedLocalVariableRule.rule.msg=未使用的局部变量
java.best.practices.UnusedLocalVariableRule.violation.msg=避免存在未使用的局部变量''%s''
java.best.practices.UnusedLocalVariableRule.rule.desc=声明和/或分配的局部变量但未使用，名称以ignored或unused开头的变量会被过滤掉。

java.best.practices.UnusedPrivateFieldRule.rule.msg=未使用的私有字段
java.best.practices.UnusedPrivateFieldRule.violation.msg=避免存在未使用的私有字段''%s''
java.best.practices.UnusedPrivateFieldRule.rule.desc=声明的私有字段和/或为其赋值但未使用。

java.best.practices.UnusedPrivateMethodRule.rule.msg=未使用的私有方法
java.best.practices.UnusedPrivateMethodRule.violation.msg=避免免存在未使用的私有方法''%s''
java.best.practices.UnusedPrivateMethodRule.rule.desc=声明了私有方法但未使用。

java.best.practices.UseCollectionIsEmptyRule.rule.msg=Collection使用isEmpty来判空
java.best.practices.UseCollectionIsEmptyRule.violation.msg=(size() == 0 or size() != 0 or size() < 0 or size() > 1)\
  建议使用isEmpty来判空
java.best.practices.UseCollectionIsEmptyRule.rule.desc=java.util.Collection上的isEmpty()方法用于确定集合是否包含任何元\
  素。将size()的值与0进行比较并不能像isEmpty()那样传达意图。

java.best.practices.UseStandardCharsetsRule.rule.msg=使用StandardCharsets
java.best.practices.UseStandardCharsetsRule.violation.msg=建议使用StandardCharsets
java.best.practices.UseStandardCharsetsRule.rule.desc=StandardCharsets 提供常见Charset对象的常量，例如UTF-8。\
  Charset.forName(...)与不需要扫描内部缓存相比，使用常量更不容易出错，并且可以提供较小的性能优势Charset。

java.best.practices.UnusedAssignmentRule.rule.msg=未使用的分配
java.best.practices.UnusedAssignmentRule.violation.msg=分配给变量''%s''的值从未被使用或总是被覆盖
java.best.practices.UnusedAssignmentRule.rule.desc=该变量在赋值后永远不会被读取或者在下次获取变量之前分配的值始终会被其他分配覆盖。\
  此规则不考虑对this构造函数中的字段或静态初始值设定项中当前类的静态字段之外的字段进行赋值。

java.best.practices.UseTryWithResourcesRule.rule.msg=使用try-with-resources语句
java.best.practices.UseTryWithResourcesRule.violation.msg=建议使用try-with-resources语句
java.best.practices.UseTryWithResourcesRule.rule.desc=try-with-resources 语句。该语句确保每个资源在语句结束时关闭。\
  它避免了在finally块中显式关闭资源的需要。此外，可以更好地处理异常：如果异常同时发生在try块和finally块中，则来自try块的异常将被抑制。\
  使用try-with-resources 语句，会保留从try块抛出的异常。


java.code.style.AvoidProtectedFieldInFinalClassRule.rule.msg=避免在final类中的Protected字段
java.code.style.AvoidProtectedFieldInFinalClassRule.violation.msg=避免在final类中使用Protected字段''%s''
java.code.style.AvoidProtectedFieldInFinalClassRule.rule.desc=不要在final类中使用受保护的字段，因为它们不能被子类化。通过使用私有或包访问修饰符来阐明您的意图。

java.code.style.AvoidProtectedMethodInFinalClassNotExtendingRule.rule.msg=避免在final类中的Protected方法
java.code.style.AvoidProtectedMethodInFinalClassNotExtendingRule.violation.msg=避免在final类中使用Protected方法''%s''
java.code.style.AvoidProtectedMethodInFinalClassNotExtendingRule.rule.desc=不要在大多数final类中使用受保护的方法，因为它们\
  不能被子类化。这只应在使用受保护方法（其可见性不能降低）扩展其他类的final类中允许。通过使用私有或包访问修饰符来阐明您的意图。

java.code.style.BooleanGetMethodNameRule.rule.msg=返回是boolean值的方法的命名建议
java.code.style.BooleanGetMethodNameRule.violation.msg=避免在返回是boolean值的方法的命名带有get前缀''%s''
java.code.style.BooleanGetMethodNameRule.rule.desc=返回布尔结果的方法应命名为谓词语句来表示这一点。\
  即“isReady()”、“hasValues()”、“canCommit()”、“willFail()”等。避免在这些方法中使用“get”前缀。

java.code.style.ClassNamingConventionsRule.rule.msg=类命名约定
java.code.style.ClassNamingConventionsRule.violation.msg=%s的命名''%s''不符合约定''%s''
java.code.style.ClassNamingConventionsRule.rule.desc=类名使用UpperCamelCase风格，必须遵从驼峰形式\
  (但以下情形例外：领域模型的相关命名DO/BO/DTO/VO/DAO及和X产品相关的命名XProduct/OneXProduct)，抽象类必须以Abstract或Base开头,\
  单元测试类必须以Test开头或Test/Tests/TestCase结尾。

java.code.style.ControlStatementBracesRule.rule.msg=控制语句包含大括号
java.code.style.ControlStatementBracesRule.violation.msg=控制语句必须包含大括号
java.code.style.ControlStatementBracesRule.rule.desc=对控制语句执行大括号策略。建议在“if … \
  else”语句和循环语句上使用大括号，即使只有一条语句。这通常会使代码更清晰，并有助于为将来需要添加另一个语句时做好准备。

java.code.style.EmptyControlStatementRule.rule.msg=空控制语句
java.code.style.EmptyControlStatementRule.finally.violation.msg=finally语句块是空的
java.code.style.EmptyControlStatementRule.synchronized.violation.msg=synchronized语句块是空的
java.code.style.EmptyControlStatementRule.switch.violation.msg=switch语句块是空的
java.code.style.EmptyControlStatementRule.block.violation.msg=block语句块是空的
java.code.style.EmptyControlStatementRule.if.violation.msg=if语句块是空的
java.code.style.EmptyControlStatementRule.else.violation.msg=else语句块是空的
java.code.style.EmptyControlStatementRule.while.violation.msg=while语句块是空的
java.code.style.EmptyControlStatementRule.for.violation.msg=for语句块是空的
java.code.style.EmptyControlStatementRule.do.violation.msg=do...while语句块是空的
java.code.style.EmptyControlStatementRule.initializer.violation.msg=initializer语句块是空的
java.code.style.EmptyControlStatementRule.try.violation.msg=try语句块是空的
java.code.style.EmptyControlStatementRule.rule.desc=主体为空的控制语句以及空的初始值设定项

java.code.style.EmptyMethodInAbstractClassShouldBeAbstractRule.rule.msg=抽象类中的空方法建议添加abstract关键字
java.code.style.EmptyMethodInAbstractClassShouldBeAbstractRule.violation.msg=抽象类中的空方法建议添加abstract关键字
java.code.style.EmptyMethodInAbstractClassShouldBeAbstractRule.rule.desc=抽象类中的空或自动生成的方法应标记为抽象。这有助于\
  消除应该在具体子类中实现自己的版本的开发人员的不当使用

java.code.style.FieldNamingConventionsRule.rule.msg=字段命名约定
java.code.style.FieldNamingConventionsRule.violation.msg=%s的命名''%s''不符合约定''%s''
java.code.style.FieldNamingConventionsRule.rule.desc=字段命名使用ALL_UPPER命名法。

java.code.style.FormalParameterNamingConventionsRule.rule.msg=参数命名约定
java.code.style.FormalParameterNamingConventionsRule.violation.msg=%s的命名''%s''不符合约定''%s''
java.code.style.FormalParameterNamingConventionsRule.rule.desc=参数命名使用首字母小写CamelCase命名法。

java.code.style.GenericsNamingRule.rule.msg=泛型命名约定
java.code.style.GenericsNamingRule.violation.msg=泛型命名使用大写字母
java.code.style.GenericsNamingRule.rule.desc=泛型命名建议使用大写字母。

java.code.style.LinguisticNamingRule.rule.msg=方法、字段、变量等命名是否符合语言规律检查
java.code.style.LinguisticNamingRule.TransformMethods.violation.msg=transform方法''%s''不应该返回void，这不符合命名意义。
java.code.style.LinguisticNamingRule.Getters.violation.msg=get方法''%s''不应该返回void，这不符合命名意义。
java.code.style.LinguisticNamingRule.Setters.violation.msg=set方法''%s''不应该返回任何类型，这不符合命名意义。
java.code.style.LinguisticNamingRule.BooleanMethods.violation.msg=方法''%s''应该返回boolean类型，但是现在返回''%s''类型，\
  这不符合命名意义。建议返回boolean类型的方法命名用is|has|can|have|will|should开头
java.code.style.LinguisticNamingRule.Field.violation.msg=字段''%s''在语言上表明应该是boolean类型，但是现在是''%s''类型，\
  这不符合命名意义。
java.code.style.LinguisticNamingRule.Variable.violation.msg=变量''%s''在语言上表明应该是boolean类型，但是现在是''%s''类型，\
  这不符合命名意义。
java.code.style.LinguisticNamingRule.rule.desc=该规则查找语言命名反模式。它检查已命名的字段，就好像它们应该是布尔值但具有不同的\
  类型。它还检查方法，根据它们的名称，这些方法应该返回布尔值，但实际上却没有。此外，它还检查 getter 是否返回某些内容，而 setter 则不会。

java.code.style.LocalVariableCouldBeFinalRule.rule.msg=不会重新分配的局部建议声明为final
java.code.style.LocalVariableCouldBeFinalRule.violation.msg=局部变量''%s''可以声明为final
java.code.style.LocalVariableCouldBeFinalRule.rule.desc=仅分配一次的局部变量可以声明为final。

java.code.style.LocalVariableNamingConventionsRule.rule.msg=局部变量命名约定
java.code.style.LocalVariableNamingConventionsRule.violation.msg=%s的命名''%s''不符合约定''%s''
java.code.style.LocalVariableNamingConventionsRule.rule.desc=局部变量使用首字母小写CamelCase命名法。

java.code.style.LongVariableRule.rule.msg=长变量约定
java.code.style.LongVariableRule.violation.msg=避免字段或参数或局部变量''%s''名称的长度超过30。
java.code.style.LongVariableRule.rule.desc=太长的字段、参数或局部变量名称可能会使代码难以理解。

java.code.style.MethodNamingConventionsRule.rule.msg=方法名命名约定
java.code.style.MethodNamingConventionsRule.violation.msg=%s的命名''%s''不符合约定''%s''
java.code.style.MethodNamingConventionsRule.rule.desc=方法名使用首字母小写CamelCase命名法。

java.code.style.PackageCaseRule.rule.msg=包命名规范
java.code.style.PackageCaseRule.violation.msg=包名''%s''含有大写的字母
java.code.style.PackageCaseRule.rule.desc=包命名必须需要全小写字母

java.code.style.PrematureDeclarationRule.rule.msg=过早定义变量
java.code.style.PrematureDeclarationRule.violation.msg=变量''%s''过早被定义
java.code.style.PrematureDeclarationRule.rule.desc=变量在不使用该变量但也能够返回或引发异常的代码块之前创建的，则该变量被认为\
  是过早定义的。

java.code.style.UnnecessaryCastRule.rule.msg=不必要的强制转换
java.code.style.UnnecessaryCastRule.violation.msg=避免不必要的强制转换''%s''
java.code.style.UnnecessaryCastRule.rule.desc=访问集合元素时不需要强制转换

java.code.style.UnnecessaryLocalBeforeReturnRule.rule.msg=避免创建不必要的局部变量
java.code.style.UnnecessaryLocalBeforeReturnRule.violation.msg=避免创建不必要的局部变量''%s''
java.code.style.UnnecessaryLocalBeforeReturnRule.rule.desc=避免创建不必要的局部变量

java.code.style.UnnecessaryConstructorRule.rule.msg=不必要的构造函数
java.code.style.UnnecessaryConstructorRule.violation.msg=避免不必要的构造函数，编译器将为您生成这些构造函数。
java.code.style.UnnecessaryConstructorRule.rule.desc=当只有一个构造函数并且构造函数与默认构造函数相同时不需要创建此构造函数。请\
  注意：默认构造函数应该具有相同的访问权限修饰符作为声明类。

java.code.style.UnnecessaryModifierRule.rule.msg=不必要的修饰语
java.code.style.UnnecessaryModifierRule.violation.msg=不必要的修饰语''%s''在%s ''%s''中。
java.code.style.UnnecessaryModifierRule.rule.desc=接口和注释中的字段自动为“public static final”，方法为“public abstract”。\
  嵌套在接口或注释中的类、接口或注释自动为“public static”所有嵌套接口和注释自动是静态的）。嵌套枚举自动为“静态”。由于历史原因，编译器\
  接受上下文隐含的修饰符，但这是多余的。

java.design.AvoidDeeplyNestedIfStmtsRule.rule.msg=避免深度嵌套if语句
java.design.AvoidDeeplyNestedIfStmtsRule.violation.msg=避免深度嵌套if语句
java.design.AvoidDeeplyNestedIfStmtsRule.rule.desc=避免创建深层嵌套的if-then语句(阀值3)，因为它们更难以阅读并且易于维护错误。

java.design.AvoidRethrowingExceptionRule.rule.msg=避免重新抛出异常
java.design.AvoidRethrowingExceptionRule.violation.msg=避免重新抛出异常
java.design.AvoidRethrowingExceptionRule.rule.desc=仅仅重新抛出捕获的异常的Catch块只会增加代码大小和运行时复杂性。

java.design.AvoidThrowingNewInstanceOfSameExceptionRule.rule.msg=避免重新抛出相同异常类型的新实例
java.design.AvoidThrowingNewInstanceOfSameExceptionRule.violation.msg=避免重新抛出相同异常类型的新实例
java.design.AvoidThrowingNewInstanceOfSameExceptionRule.rule.desc=仅重新抛出相同异常类型的新实例中的Catch块只会增加代码大小和运行时复杂性。

java.design.AvoidThrowingNullPointerExceptionRule.rule.msg=避免抛出NullPointerException
java.design.AvoidThrowingNullPointerExceptionRule.violation.msg=避免抛出NullPointerException
java.design.AvoidThrowingNullPointerExceptionRule.rule.desc=避免手动抛出 NullPointerException。这些很令人困惑，因为大多数人\
  会认为是虚拟机抛出的。为了避免使用null参数调用方法，您可以考虑使用IllegalArgumentException来代替，使其清楚地被视为程序员启动的异常。

java.design.ClassWithOnlyPrivateConstructorsShouldBeFinalRule.rule.msg=仅具有私有构造函数的类应该声明为final
java.design.ClassWithOnlyPrivateConstructorsShouldBeFinalRule.violation.msg=仅具有私有构造函数的类''%s''应该是声明为final
java.design.ClassWithOnlyPrivateConstructorsShouldBeFinalRule.rule.desc=仅具有私有构造函数的类应该声明为final，除非私有构造函数由内部类调用。

java.design.CognitiveComplexityRule.rule.msg=认知复杂性
java.design.CognitiveComplexityRule.Method.violation.msg=方法''%s''认知复杂度为%s, 当前阀值是%s。
java.design.CognitiveComplexityRule.Constructor.violation.msg=构造函数''%s''认知复杂度为%s, 当前阀值是%s。
java.design.CognitiveComplexityRule.rule.desc=高度复杂的方法难以阅读并且维护成本更高。如果在单个方法中包含太多决策逻辑，\
  则会使其行为难以理解并且更难以修改。有关认知复杂性的信息可详见：https ://www.sonarsource.com/docs/CognitiveComplexity.pdf

java.design.CollapsibleIfStatementsRule.rule.msg=可合并的if语句
java.design.CollapsibleIfStatementsRule.violation.msg=可合并if语句
java.design.CollapsibleIfStatementsRule.rule.desc=可以通过用布尔运算符合并两个连续的“if”语句。

java.design.CouplingBetweenObjectsRule.rule.msg=对象的耦合度较高
java.design.CouplingBetweenObjectsRule.violation.msg=对象的耦合度较高，当前的耦合度为%s，超过阀值%s。
java.design.CouplingBetweenObjectsRule.rule.desc=计算对象中唯一属性、局部变量和返回类型的数量。高于指定阈值表明耦合程度较高。

java.design.FinalFieldCouldBeStaticRule.rule.msg=声明为final的字段可设置为static
java.design.FinalFieldCouldBeStaticRule.violation.msg=声明为final的字段''%s''可设置为static。
java.design.FinalFieldCouldBeStaticRule.rule.desc=将final字段分配给编译时的常量，则可以将其设置为静态，从而节省每个对象在运行时的开销。

java.design.ImmutableFieldRule.rule.msg=不可变字段
java.design.ImmutableFieldRule.violation.msg=私有字段''%s''如果只在声明中或者构造函数中初始化，可以设置为final。
java.design.ImmutableFieldRule.rule.desc=标识私有字段，一旦对象初始化在字段声明中或通过构造函数结束，其值就永远不会改变。\
  这有助于将现有类转换为不可变类。请注意，此规则并不强制引用的对象本身不可变。即使类的所有成员字段都声明为final类，类仍然可以是可变的。\
  这称为浅层不变性。有关可变性的更多信息，请参阅《Effective Java》，第3版，第17项：最小化可变性。

java.design.LogicInversionRule.rule.msg=逻辑反转
java.design.LogicInversionRule.violation.msg=使用相反的运算符
java.design.LogicInversionRule.rule.desc=使用相反的运算符，而不是使用逻辑非运算符来否定整个表达式。

java.design.MutableStaticStateRule.rule.msg=非私有静态字段声明为final字段
java.design.MutableStaticStateRule.violation.msg=非私有静态字段声明为最终字段来使其成为常量或不可变引用
java.design.MutableStaticStateRule.rule.desc=非private final static字段会破坏封装，并可能导致难以发现错误，因为可以从程序内的任何位置\
  修改这些字段。调用者可以轻松访问和修改非private final static字段。无法防止访问或修改，并且无法验证新设置的值。

java.design.NcssCountRule.rule.msg=Ncss计数
java.design.NcssCountRule.Class.violation.msg=%s''%s''通过Ncss统计后的行数是%s(最大行数是%s)，超过阀值%s。
java.design.NcssCountRule.Method.violation.msg=方法''%s''通过Ncss统计后的行数是%s，超过阀值%s。
java.design.NcssCountRule.Constructor.violation.msg=构造函数''%s''通过Ncss统计后的行数是%s，超过阀值%s。
java.design.NcssCountRule.rule.desc=此规则使用Ncss（非注释源语句）指标来确定类、方法或构造函数中的代码行数。如果类、方法或者构造\
  函数的代码行数超过指定阀值一般认为该类、方法或者构造函数是需要重构使代码的逻辑更加清晰和合理。Ncss忽略注释、空行，只计算实际语句。\
  NCSS统计逻辑可详见：https://docs.pmd-code.org/pmd-doc-6.55.0/pmd_java_metrics_index.html#non-commenting-source-statements-ncss

java.design.NPathComplexityRule.rule.msg=NPath复杂度
java.design.NPathComplexityRule.Method.violation.msg=方法''%s''通过NPath复杂度是%s，超过阀值%s。
java.design.NPathComplexityRule.Constructor.violation.msg=构造函数''%s''通过路径复杂度%s，超过阀值%s。
java.design.NPathComplexityRule.rule.desc=方法的NPath复杂度是通过该方法的非循环执行路径的数量。NPath计算方法块从开始到结束的完整\
  路径的数量。该指标呈指数级增长，因为它使同一块中语句的复杂性成倍增加。\
  NPath复杂度可详见：https://docs.pmd-code.org/pmd-doc-6.55.0/pmd_java_metrics_index.html#npath-complexity-npath

java.design.SimplifiedTernaryRule.rule.msg=简化三元表达式
java.design.SimplifiedTernaryRule.violation.msg=condition ? true : false可以简化为return condition;
java.design.SimplifiedTernaryRule.rule.desc=condition ? true : false可以简化为return condition;

java.design.SimplifyBooleanExpressionsRule.rule.msg=简化布尔表达式
java.design.SimplifyBooleanExpressionsRule.violation.msg=在布尔表达式中避免不必要的比较
java.design.SimplifyBooleanExpressionsRule.rule.desc=避免在布尔表达式中进行不必要的比较，它们没有任何作用并且会影响可读性。

java.design.SimplifyBooleanReturnsRule.rule.msg=简化布尔返回
java.design.SimplifyBooleanReturnsRule.violation.msg=返回布尔值时避免不必要的if-then-else语句
java.design.SimplifyBooleanReturnsRule.rule.desc=返回布尔值时避免不必要的if-then-else语句。可以改为返回条件测试的结果。

java.design.SimplifyConditionalRule.rule.msg=简化条件
java.design.SimplifyConditionalRule.violation.msg=在instanceof之前不需要检查null
java.design.SimplifyConditionalRule.rule.desc=在instanceof之前不需要检查null；当给定null参数时，instanceof关键字返回false。

java.design.SingularFieldRule.rule.msg=单字段
java.design.SingularFieldRule.violation.msg=建议''%s''替换为局部变量
java.design.SingularFieldRule.rule.desc=如果全局变量只在单个方法中被使用，可以考虑替换为局部变量。(lombok相关Annotation已设置忽略)

java.design.SwitchDensityRule.rule.msg=switch语句密度
java.design.SwitchDensityRule.violation.msg=switch语句中case标签包含的语句比例较高，考虑重构。
java.design.SwitchDensityRule.rule.desc=switch语句中case标签包含的语句比例较高意味着switch语句超载。考虑将语句移至新方法或基于switch变量创建子类。

java.design.TooManyFieldsRule.rule.msg=字段过多
java.design.TooManyFieldsRule.violation.msg=类中包含的字段过多，当前阀值%s。
java.design.TooManyFieldsRule.rule.desc=具有太多字段的类可能会变得难以使用，可以考虑重新设计以具有更少的字段，可以通过将相关字段分组到新对象中来实现。

java.design.TooManyMethodsRule.rule.msg=方法太多
java.design.TooManyMethodsRule.violation.msg=这个类的方法太多，考虑重构。
java.design.TooManyMethodsRule.rule.desc=具有太多方法的类可能需要重构，以降低其复杂性并找到一种拥有更细粒度对象的方法。

java.design.UselessOverridingMethodRule.rule.msg=无用的重写方法
java.design.UselessOverridingMethodRule.violation.msg=Overriding方法仅调用了超类中定义的相同方法。
java.design.UselessOverridingMethodRule.rule.desc=重写方法仅调用超类中定义的相同方法。

java.design.UseObjectForClearerAPIRule.rule.msg=使用容器对象可以使API更清晰
java.design.UseObjectForClearerAPIRule.violation.msg=不要使用大量字符串参数，而是考虑使用这些值的容器对象。
java.design.UseObjectForClearerAPIRule.rule.desc=当您编写公共方法时，您应该从 API 的角度进行思考。如果您的方法是公共的，\
  则意味着其他类将使用它，因此，您希望（或需要）提供全面且不断发展的 API。如果您将大量信息作为一系列简单的字符串传递，您可能会考虑使用\
  对象来表示所有这些信息。您将获得一个更简单的API，而不是一系列繁琐的字符，更重要的是如果您在某些时候需要传递额外的数据，您将能够通过\
  简单地修改或扩展API来实现，而无需对API进行任何修改。

java.design.ExcessiveParameterListRule.rule.msg=参数过多
java.design.ExcessiveParameterListRule.violation.msg=避免方法中包含过多的参数，当前阀值10。
java.design.ExcessiveParameterListRule.rule.desc=具有大量参数的方法是维护的一个挑战，特别是如果它们中的大多数共享相同的数据类型。\
  这些情况通常表示需要新对象来包装众多参数。

java.design.ExcessivePublicCountRule.rule.msg=Public属性/方法过多
java.design.ExcessivePublicCountRule.violation.msg=类的public属性或方法太多。当前阀值45。
java.design.ExcessivePublicCountRule.rule.desc=具有大量公共方法和属性的类需要不成比例的测试工作，因为组合副作用会迅速增长并增加风\
  险。将这些类重构为更小的类不仅可以提高可测试性和可靠性

java.documentation.CommentContentRule.rule.msg=注释内容
java.documentation.CommentContentRule.violation.msg=不要在注释中包含带有歧视性的语言。
java.documentation.CommentContentRule.rule.desc=不要在注释中包含带有歧视性的语言。

java.documentation.CommentRequiredRule.rule.msg=注释必填
java.documentation.CommentRequiredRule.violation.msg=需要包含''%s''注释
java.documentation.CommentRequiredRule.rule.desc=public、protected方法及类、字段、枚举需要包含注释

java.multithreading.AvoidThreadGroupRule.rule.msg=避免使用ThreadGroup
java.multithreading.AvoidThreadGroupRule.violation.msg=避免使用java.lang.ThreadGroup因为它包含线程不安全的方法
java.multithreading.AvoidThreadGroupRule.rule.desc=避免使用java.lang.ThreadGroup，尽管它可以在线程环境中使用，但它包含线程不安全的方法。

java.multithreading.DoubleCheckedLockingRule.rule.msg=双重检查锁定
java.multithreading.DoubleCheckedLockingRule.violation.msg=Java中的双重检查锁定不是线程安全的，需要添加volatile关键字，禁止指令重排。
java.multithreading.DoubleCheckedLockingRule.rule.desc=Java中的双重检查锁定不是线程安全的，需要添加volatile关键字，禁止指令重排。

java.multithreading.UnSynchronizedStaticFormatterRule.rule.msg=应以同步方式访问静态Formatter对象
java.multithreading.UnSynchronizedStaticFormatterRule.violation.msg=应以同步方式访问静态Formatter对象
java.multithreading.UnSynchronizedStaticFormatterRule.rule.desc=如果多个线程必须访问静态格式化程序，则该format方法必须添加synchronized关键字。

java.performance.AddEmptyStringRule.rule.msg=避免添加空字符串
java.performance.AddEmptyStringRule.violation.msg=避免通过添加空字符串来链接文字
java.performance.AddEmptyStringRule.rule.desc=通过将文字与空字符串连接来将文字转换为字符串的效率很低。最好使用一种特定于类型\
  的toString()方法来代替或String.valueOf()。

java.performance.AppendCharacterWithCharRule.rule.msg=使用StringBuffer或StringBuilder添加单个字符时候避免添加String
java.performance.AppendCharacterWithCharRule.violation.msg=使用StringBuffer或StringBuilder添加单个字符时候避免添加String
java.performance.AppendCharacterWithCharRule.rule.desc=避免在StringBuffer/StringBuilder.append方法中将字符连接为字符串。

java.performance.AvoidCalendarDateCreationRule.rule.msg=避免使用Calendar创建日期
java.performance.AvoidCalendarDateCreationRule.violation.msg=避免使用Calendar创建日期
java.performance.AvoidCalendarDateCreationRule.rule.desc=Calendar是重量级对象，创建成本昂贵。

java.performance.AvoidFileStreamRule.rule.msg=避免在JDK10以下版本使用FileStream
java.performance.AvoidFileStreamRule.violation.msg=避免在JDK10以下版本使用FileStream
java.performance.AvoidFileStreamRule.rule.desc=FileInputStream和FileOutputStream类包含一个终结器方法，该方法将导致GC暂停。\
  该问题已经在JDK10版本修复，详见：https://bugs.openjdk.org/browse/JDK-8080225。\
  请注意：java.nioAPI不再抛出FileNotFoundException，而是抛出NoSuchFileException。如果您的代码显式处理FileNotFoundException，则需要进行调整。

java.performance.AvoidInstantiatingObjectsInLoopsRule.rule.msg=避免在循环中实例化对象
java.performance.AvoidInstantiatingObjectsInLoopsRule.violation.msg=避免在循环中实例化对象
java.performance.AvoidInstantiatingObjectsInLoopsRule.rule.desc=避免循环内创建的新对象，看看它们是否可以在循环外创建并重用。

java.performance.BigIntegerInstantiationRule.rule.msg=不要创建已存在的BigInteger/BigDecimal的实例
java.performance.BigIntegerInstantiationRule.violation.msg=不要创建已存在的BigInteger/BigDecimal的实例
java.performance.BigIntegerInstantiationRule.rule.desc=不要创建已存在的BigInteger.ZERO、BigInteger.ONE、BigInteger.TEN、\
  BigDecimal.ZERO, BigDecimal.ONE, BigDecimal.TEN的实例。

java.performance.ConsecutiveAppendsShouldReuseRule.rule.msg=连续的Append应该重用
java.performance.ConsecutiveAppendsShouldReuseRule.violation.msg=对StringBuffer/StringBuilder的append方法有连续调用应该链接起来，重用目标对象
java.performance.ConsecutiveAppendsShouldReuseRule.rule.desc=对StringBuffer/StringBuilder的append方法有连续调用应该链接起\
  来，重用目标对象。这可以通过生成更小的字节码、减少开销和改进内联来提高性能。完整分析可以查看：\
  https://github.com/pmd/pmd/issues/202#issuecomment-274349067

java.performance.ConsecutiveLiteralAppendsRule.rule.msg=避免连续的文字append
java.performance.ConsecutiveLiteralAppendsRule.violation.msg=使用文字连续调用StringBuffer/StringBuilder.append %s次。\
  由于文字是常量，因此它们已经可以组合成单个字符串文字，并且可以在单个方法调用中附加该字符串。
java.performance.ConsecutiveLiteralAppendsRule.rule.desc=避免使用文字连续调用StringBuffer/StringBuilder.append(...)。\
  由于文字是常量，因此它们已经可以组合成单个字符串文字，并且可以在单个方法调用中附加该字符串。

java.performance.InefficientStringBufferingRule.rule.msg=低效的字符串缓冲
java.performance.InefficientStringBufferingRule.violation.msg=避免在StringBuffer构造函数或append()中连接非文字，因为中间缓冲区需要由JVM创建和销毁。
java.performance.InefficientStringBufferingRule.rule.desc=避免在StringBuffer构造函数或append()中连接非文字，因为中间缓冲区需要由JVM创建和销毁。

java.performance.InsufficientStringBufferDeclarationRule.rule.msg=字符串缓冲区声明不足
java.performance.InsufficientStringBufferDeclarationRule.violation.msg=%s已初始化为大小%s，但至少附加了%s个字符。
java.performance.InsufficientStringBufferDeclarationRule.rule.desc=未能正确预先调整StringBuffer或StringBuilder的大小可\
  能会导致其在运行时多次调整大小。空的StringBuffer/StringBuilder构造函数将对象初始化为16个字符，如果无法确定构造函数的长度，则采用此默认值。

java.performance.OptimizableToArrayCallRule.rule.msg=可优化数组调用
java.performance.OptimizableToArrayCallRule.violation.msg=对集合toArray(E[])方法的调用应指定大小为零的目标数组。这使得JVM能够尽可能地优化内存分配和复制。
java.performance.OptimizableToArrayCallRule.rule.desc=对集合toArray(E[])方法的调用应指定大小为零的目标数组。这使得JVM能够尽可能地优化内存分配和复制。

java.performance.RedundantFieldInitializerRule.rule.msg=避免进行默认值初始化字段设定
java.performance.RedundantFieldInitializerRule.violation.msg=避免对''%s''进行默认值初始化字段设定
java.performance.RedundantFieldInitializerRule.rule.desc=Java将使用已知的默认值初始化字段，因此这些相同默认值的任何显式初始化\
  都是多余的，并会导致更大的类文件（每个字段大约三个额外的字节码指令）。

java.performance.StringInstantiationRule.rule.msg=避免字符串实例化
java.performance.StringInstantiationRule.violation.msg=避免实例化String对象
java.performance.StringInstantiationRule.rule.desc=避免实例化String对象，这通常是不必要的，因为它们是不可变的并且可以安全地共享。

java.performance.StringToStringRule.rule.msg=避免String转String
java.performance.StringToStringRule.violation.msg=避免对已知为字符串实例的对象调用toString()
java.performance.StringToStringRule.rule.desc=避免对已知为字符串实例的对象调用toString()，这是不必要的。

java.performance.TooFewBranchesForASwitchStatementRule.rule.msg=少于三个分支的switch语言改用if
java.performance.TooFewBranchesForASwitchStatementRule.violation.msg=少于三个分支的switch效率低下，请改用if语句。
java.performance.TooFewBranchesForASwitchStatementRule.rule.desc=Switch语句旨在用于支持复杂的分支行为。仅在少数情况下使用switch\
  是不明智的，因为开关不像if-else语句那么容易理解。在这些情况下，请使用if-else语句来提高代码的可读性。

java.performance.UseIndexOfCharRule.rule.msg=单个字符索引使用String.indexOf(char)
java.performance.UseIndexOfCharRule.violation.msg=String.indexOf(char)比String.indexOf(String)更快.
java.performance.UseIndexOfCharRule.rule.desc=检查单个字符的索引时使用String.indexOf(char) ，它执行得更快。

java.performance.UseIOStreamsWithApacheCommonsFileItemRule.rule.msg=避免内存密集型方法FileItem.get()或FileItem.getString()
java.performance.UseIOStreamsWithApacheCommonsFileItemRule.violation.msg=避免内存密集型方法FileItem.get()或FileItem.getString()
java.performance.UseIOStreamsWithApacheCommonsFileItemRule.rule.desc=使用FileItem.get()和FileItem.getString()可能会耗尽内存，\
  因为它们将整个文件加载到内存中。建议使用FileItem.getInputStream()和缓冲。

java.performance.UselessStringValueOfRule.rule.msg=避免使用String.valueOf()
java.performance.UselessStringValueOfRule.violation.msg=无需调用String.valueOf来添加到字符串。
java.performance.UselessStringValueOfRule.rule.desc=无需调用String.valueOf来添加字符串；只需直接使用valueOf()参数即可。

java.performance.UseStringBufferForStringAppendsRule.rule.msg=使用StringBuffer或StringBuilder来连接字符串
java.performance.UseStringBufferForStringAppendsRule.violation.msg=对于连接字符串，优先使用StringBuilder或StringBuffer而不是用"+="
java.performance.UseStringBufferForStringAppendsRule.rule.desc=使用“+=”运算符附加字符串会导致 JVM 创建并使用内部StringBuffer。\
  如果使用的这些连接数量不少，则建议显式使用StringBuilder或线程安全StringBuffer来避免这种情况。

java.performance.UseStringBufferLengthRule.rule.msg=使用StringBuffer.length()
java.performance.UseStringBufferLengthRule.violation.msg=StringBuffer.toString()是低效的使用，应该调用StringBuffer.length() 。
java.performance.UseStringBufferLengthRule.rule.desc=使用StringBuffer.length()来确定StringBuffer长度，而不是使用\
  StringBuffer.toString().equals("")或StringBuffer.toString().length()

java.errorprone.AssignmentInOperandRule.rule.msg=操作数赋值
java.errorprone.AssignmentInOperandRule.violation.msg=避免在操作数中赋值。
java.errorprone.AssignmentInOperandRule.rule.desc=避免在操作数中赋值，这会使代码更加复杂且难以阅读。

java.errorprone.AssignmentToNonFinalStaticRule.rule.msg=给不是final的static字段赋值
java.errorprone.AssignmentToNonFinalStaticRule.violation.msg=对构造函数中的不是final的static字段''%s''可能存在不安全的赋值。
java.errorprone.AssignmentToNonFinalStaticRule.rule.desc=识别static资源不安全的使用

java.errorprone.AvoidDecimalLiteralsInBigDecimalConstructorRule.rule.msg=避免使用float/double创建BigDecimal
java.errorprone.AvoidDecimalLiteralsInBigDecimalConstructorRule.violation.msg=避免创建BigDecimal使用float/double,建议使用String
java.errorprone.AvoidDecimalLiteralsInBigDecimalConstructorRule.rule.desc=一般会认为“new BigDecimal(0.1)”的结果恰好等于\
  0.1，但它实际上等于0.1000000000000000055511151231257827021181583404541015625。这是因为0.1不能精确地表示为双精度型（或任何有限长度的二进制分数）。

java.errorprone.AvoidDuplicateLiteralsRule.rule.msg=避免重复文字
java.errorprone.AvoidDuplicateLiteralsRule.violation.msg=字符串文字%s在此文件中出现%s次，第一次出现在第%s行。
java.errorprone.AvoidDuplicateLiteralsRule.rule.desc=包含重复字符串的代码建议可以将字符串声明为常量字段。

java.errorprone.AvoidFieldNameMatchingMethodNameRule.rule.msg=避免字段名称和方法名称相同
java.errorprone.AvoidFieldNameMatchingMethodNameRule.violation.msg=字段''%s''与方法同名。
java.errorprone.AvoidFieldNameMatchingMethodNameRule.rule.desc=字段名与方法同名可能会造成混淆。虽然这是允许的。

java.errorprone.AvoidFieldNameMatchingTypeNameRule.rule.msg=避免字段名称和类型名称相同
java.errorprone.AvoidFieldNameMatchingTypeNameRule.violation.msg=字段''%s''名称与声明类名称相同。
java.errorprone.AvoidFieldNameMatchingTypeNameRule.rule.desc=字段名称与声明类型名称相同会有点令人困惑。

java.errorprone.AvoidInstanceofChecksInCatchClauseRule.rule.msg=避免在catch中处理不是本catch捕获的异常类型
java.errorprone.AvoidInstanceofChecksInCatchClauseRule.violation.msg=每个捕获的异常类型都应在其自己的catch子句中处理。
java.errorprone.AvoidInstanceofChecksInCatchClauseRule.rule.desc=每个捕获的异常类型都应在其自己的catch子句中处理。

java.errorprone.AvoidLiteralsInIfConditionRule.rule.msg=避免在if条件语句下使用硬编码
java.errorprone.AvoidLiteralsInIfConditionRule.violation.msg=避免在if条件语句下使用硬编码。
java.errorprone.AvoidLiteralsInIfConditionRule.rule.desc=避免在条件语句中使用硬编码。通过将它们声明为静态变量或具有描述性名称的私有成员。

java.errorprone.AvoidMultipleUnaryOperatorsRule.rule.msg=避免多个一元运算符
java.errorprone.AvoidMultipleUnaryOperatorsRule.violation.msg=避免使用多个一元运算符。
java.errorprone.AvoidMultipleUnaryOperatorsRule.rule.desc=使用多个一元运算符可能会出现问题and/or令人困惑。确保预期用途不是错误，或者考虑简化表达式。

java.errorprone.ClassCastExceptionWithToArrayRule.rule.msg=避免ClassCastException异常
java.errorprone.ClassCastExceptionWithToArrayRule.violation.msg=使用Collection.toArray()方法将抛出ClassCastException。
java.errorprone.ClassCastExceptionWithToArrayRule.rule.desc=当从Collection中派生特定类的数组时，应该提供一组与toArray()方法\
  的参数相同的类。否则会导致ClassCastException异常。

java.errorprone.CloneMethodMustBePublicRule.rule.msg=clone方法必须是public的
java.errorprone.CloneMethodMustBePublicRule.violation.msg=如果类实现Cloneable，clone()方法必须是公共的。
java.errorprone.CloneMethodMustBePublicRule.rule.desc=如果类实现Cloneable，clone()方法必须是公共的。

java.errorprone.CloneMethodReturnTypeMustMatchClassNameRule.rule.msg=clone方法的返回类型必须和类名相同
java.errorprone.CloneMethodReturnTypeMustMatchClassNameRule.violation.msg=当实现cloneable时，clone()方法的返回类型必须是类名。
java.errorprone.CloneMethodReturnTypeMustMatchClassNameRule.rule.desc=如果类实现了cloneable，则方法clone()的返回类型必须是类名。

java.errorprone.CompareObjectsWithEqualsRule.rule.msg=比较对象使用equals方法
java.errorprone.CompareObjectsWithEqualsRule.violation.msg=使用equals()来比较对象引用。
java.errorprone.CompareObjectsWithEqualsRule.rule.desc=使用equals()来比较对象引用，避免使用“==”进行比较。

java.errorprone.DoNotThrowExceptionInFinallyRule.rule.msg=在finally中不要抛出异常
java.errorprone.DoNotThrowExceptionInFinallyRule.violation.msg=finally块中的throw语句使控制流难以理解。
java.errorprone.DoNotThrowExceptionInFinallyRule.rule.desc=在“finally”块中抛出异常会令人困惑，因为它们可能会掩盖其他异常或代码缺陷。

java.errorprone.EmptyCatchBlockRule.rule.msg=空catch块
java.errorprone.EmptyCatchBlockRule.violation.msg=避免空的catch块。
java.errorprone.EmptyCatchBlockRule.rule.desc=避免catch异常但不执行任何操作。可以通过allowExceptionNameRegex属性配置需要忽略\
  的exception名称，默认是ignored和expected。

java.errorprone.ImplicitSwitchFallThroughRule.rule.msg=switch的case选项没有break或return语句
java.errorprone.ImplicitSwitchFallThroughRule.violation.msg=switch语句不包含break或return
java.errorprone.ImplicitSwitchFallThroughRule.rule.desc=对于每个case选项，没有break或return语句的switch语句可能表明有问题的行为。

java.errorprone.InstantiationToGetClassRule.rule.msg=避免实例化对象调用getClass()
java.errorprone.InstantiationToGetClassRule.violation.msg=避免实例化对象调用getClass()，请改用.class公共成员。
java.errorprone.InstantiationToGetClassRule.rule.desc=避免实例化对象调用getClass()，请改用.class公共成员。

java.errorprone.MethodWithSameNameAsEnclosingClassRule.rule.msg=类不应具有与类同名的非构造函数方法
java.errorprone.MethodWithSameNameAsEnclosingClassRule.violation.msg=类不应具有与类同名的非构造函数方法。
java.errorprone.MethodWithSameNameAsEnclosingClassRule.rule.desc=非构造函数方法不应与类同名。

java.errorprone.MissingSerialVersionUIDRule.rule.msg=可序列化的类缺失serialVersionUID
java.errorprone.MissingSerialVersionUIDRule.violation.msg=实现可序列化的类应该设置一个serialVersionUID。
java.errorprone.MissingSerialVersionUIDRule.rule.desc=可序列化类应该提供一个serialVersionUID字段。抽象基类还需要\
  serialVersionUID 字段。继承中的每个单独的类都需要一个自己的serialVersionUID字段。

java.errorprone.NonSerializableClassRule.rule.msg=非序列化类
java.errorprone.NonSerializableClassRule.violation.msg=可序列化类''%s''的字段''%s''属于不可序列化类型''%s''。
java.errorprone.NonSerializableClassRule.field.violation.msg=字段''%s''应该是private static final，类型为''%s''。
java.errorprone.NonSerializableClassRule.rule.desc=如果一个类被标记为“可序列化”，那么所有字段也需要可序列化。为了排除一个字段，\
  它可以被标记为transient。不考虑静态字段。

java.errorprone.OverrideBothEqualsAndHashcodeRule.rule.msg=重载应该同时覆盖equals和hashcode
java.errorprone.OverrideBothEqualsAndHashcodeRule.violation.msg=确保重载equals()和hashCode()。
java.errorprone.OverrideBothEqualsAndHashcodeRule.rule.desc=重载public boolean Object.equals(Object other) 和 \
  public int Object.hashCode()，或者都不覆盖。即使您从父类继承hashCode()，也请考虑实现hashCode并显式委托给您的超类。

java.errorprone.ProperLoggerRule.rule.msg=适当的logger字段
java.errorprone.ProperLoggerRule.violation.msg=logger定义为private static final。
java.errorprone.ProperLoggerRule.rule.desc=logger通常应定义为private static final并与正确的类关联。在需要传递logger的极少数\
  情况下，也允许使用“private final Log log;”，限制是logger需要传递到构造函数中。

java.errorprone.ReturnEmptyCollectionRatherThanNullRule.rule.msg=返回空的集合取代返回null
java.errorprone.ReturnEmptyCollectionRatherThanNullRule.violation.msg=返回一个空集合而不是“null”。
java.errorprone.ReturnEmptyCollectionRatherThanNullRule.rule.desc=对于任何返回集合（例如数组、Collection或Map）的方法，最好\
  返回一个空引用而不是一个'null'，避免NullPointerExceptions。

java.errorprone.ReturnFromFinallyBlockRule.rule.msg=从finally块中返回
java.errorprone.ReturnFromFinallyBlockRule.violation.msg==避免从finally块中返回
java.errorprone.ReturnFromFinallyBlockRule.rule.desc=避免从finally块返回，这会丢弃异常。

java.errorprone.UnconditionalIfStatementRule.rule.msg=无条件If语句
java.errorprone.UnconditionalIfStatementRule.violation.msg=不要使用条件始终为真或始终为假的“if”语句。
java.errorprone.UnconditionalIfStatementRule.rule.desc=不要使用条件始终为真或始终为假的“if”语句。

java.customization.StreamExpressionStyleRule.rule.msg=stream表达式规则
java.customization.StreamExpressionStyleRule.violation.msg=stream表达式每个节点需要换行（流表达式的首节点可换可不换,\
  比如以下例子的.stream()和.filter()。list.stream()、getStreamInfo().filter()），换行可以使stream表达式表述更加清晰直观。
java.customization.StreamExpressionStyleRule.rule.desc=stream表达式采用链式的方式呈现，为了表述的清晰和直观建议每个节点都要进行换\
  行。

java.customization.ConditionalTooLongNeedChangeLineRule.rule.msg=条件语句太长需要换行
java.customization.ConditionalTooLongNeedChangeLineRule.violation.msg=条件语句太长需要换行。
java.customization.ConditionalTooLongNeedChangeLineRule.rule.desc=条件判断语句的条件语句长度超过80个字符需要换行，条件符需要跟着\
  一起换行。

java.customization.AvoidComplexConditionalRule.rule.msg=避免使用复杂条件语句
java.customization.AvoidComplexConditionalRule.violation.msg=避免使用复杂条件语句。
java.customization.AvoidComplexConditionalRule.rule.desc=避免在条件语句中使用复杂的逻辑表达式，这可能会让其他阅读者感到困惑。

java.customization.StreamExpressionTooLongRule.rule.msg=stream表达式太长了
java.customization.StreamExpressionTooLongRule.violation.msg=stream表达式的行数超过了30行建议拆分。
java.customization.StreamExpressionTooLongRule.rule.desc=如果stream表达式太长会影响可读性和对代码的理解。如果流表达式超过30行需要进行拆分。\
  统计数量行不包含注释。

java.customization.AvoidStreamExpressionInIfStmtsRule.rule.msg=避免在if语句中使用Stream或Optional表达式
java.customization.AvoidStreamExpressionInIfStmtsRule.violation.msg=避免在if语句中使用Stream或Optional表达式。
java.customization.AvoidStreamExpressionInIfStmtsRule.rule.desc=避免在if语句中使用Stream或Optional表达式。

java.customization.UndefinedMagicConstantRule.rule.msg=魔法值
java.customization.UndefinedMagicConstantRule.violation.msg=避免出现魔法值%s.
java.customization.UndefinedMagicConstantRule.rule.desc=不允许任何魔法值（即未经定义的常量）直接出现在代码中。

java.customization.AvoidIfStmtsInSwitchStmtsRule.rule.msg=避免在switch语句中使用if语句
java.customization.AvoidIfStmtsInSwitchStmtsRule.violation.msg=避免在switch语句中使用if语句
java.customization.AvoidIfStmtsInSwitchStmtsRule.rule.desc=switch和if都是条件判断语句，两个混用可能造成代码的复杂度上升，建议\
  switch中的if语句可以重构为一个方法来使用。

java.customization.AvoidStreamExpressionInStreamExpressionRule.rule.msg=避免在stream表达式中内嵌stream表达式
java.customization.AvoidStreamExpressionInStreamExpressionRule.violation.msg=不建议在stream表达式中再嵌套stream表达式，\
  这样会使整个stream表达式异常复杂并难以理解。
java.customization.AvoidStreamExpressionInStreamExpressionRule.rule.desc=不建议在stream表达式中再嵌套stream表达式，\
  这样会使整个stream表达式异常复杂并难以理解。

java.customization.GuardClausesRule.rule.msg=卫语句
java.customization.GuardClausesRule.violation.msg=卫语句是通过对原条件进行逻辑分析，将某些要害（guard）条件优先作判断，从而简化程序的流程。
java.customization.GuardClausesRule.rule.desc=卫语句是通过对原条件进行逻辑分析，将某些要害（guard）条件优先作判断，从而简化程序的流程。\
  对于卫语句详细定义可见：https://en.wikipedia.org/wiki/Guard_(computer_science)

java.customization.CollectorsToMapUnUseThirdParamRule.rule.msg=Collectors.toMap/toConCurrentMap未使用第三个参数
java.customization.CollectorsToMapUnUseThirdParamRule.violation.msg=Collectors.toMap/toConCurrentMap如果未使用第三个参数碰\
  到有重复key将会抛出java.lang.IllegalStateException: Duplicate key错误
java.customization.CollectorsToMapUnUseThirdParamRule.rule.desc=Collectors.toMap/toConCurrentMap如果未使用第三个参数碰到有\
  重复key将会抛出java.lang.IllegalStateException: Duplicate key错误

java.customization.AvoidTooManyConditionRule.rule.msg=避免条件过多
java.customization.AvoidTooManyConditionRule.violation.msg=条件数量超过阀值%s。
java.customization.AvoidTooManyConditionRule.rule.desc=条件过多，影响代码的理解，默认阀值是4。

java.customization.AvoidUseComplexStreamExpressionInSetMethodRule.rule.msg=避免在set方法中传入复杂的流表达式
java.customization.AvoidUseComplexStreamExpressionInSetMethodRule.violation.msg=避免在set方法中传入复杂的流表达式
java.customization.AvoidUseComplexStreamExpressionInSetMethodRule.rule.desc=set方法的入参传递复杂的stream表达式会增加理解和阅读上的复杂度。

java.customization.AvoidUseUnSynchronizedFormatRule.rule.msg=避免使用没有Synchronized关键字的Format类
java.customization.AvoidUseUnSynchronizedFormatRule.violation.msg=Format是静态成员变量的场景下，使用format、parse等方法是线程不安全的。
java.customization.AvoidUseUnSynchronizedFormatRule.rule.desc=DateFormat、SimpleDateFormat、NumberFormat、MessageFormat\
  是静态成员变量的场景下，使用format、parse等方法是线程不安全的。在多线程的场景下建议使用非静态成员变量,和Date相关的可以使用Apache的\
  FastDateFormat。

java.customization.TernaryChangeLineRule.rule.msg=三元表达式换行规则
java.customization.TernaryChangeLineRule.violation.msg=三元表达式如果换行需要'?'和':'表达式一起换行
java.customization.TernaryChangeLineRule.rule.desc=三元表达式如果换行需要'?'和':'表达式一起换行。

java.customization.AvoidTernaryNestedTernaryRule.rule.msg=避免三元表达式中嵌套三元表达式
java.customization.AvoidTernaryNestedTernaryRule.violation.msg=避免三元表达式中嵌套三元表达式
java.customization.AvoidTernaryNestedTernaryRule.rule.desc=三元表达式中嵌套三元表达式会增加语句理解的复杂度。

java.customization.AvoidYodaConditionRule.rule.msg=避免使用尤达条件表达式
java.customization.AvoidYodaConditionRule.violation.msg=避免使用尤达条件表达式
java.customization.AvoidYodaConditionRule.rule.desc=尤达条件表达式虽然可以避免单个等号的赋值操作，但是此方式不符合阅读的习惯。\
  建议把常量放在条件语句的左侧或者使用Objects.isNull、Objects.equals等方法。

java.customization.AvoidUseSetFuncInGetMethodRule.rule.msg=避免在get方法中进行set操作
java.customization.AvoidUseSetFuncInGetMethodRule.violation.msg=避免在get开头的方法中使用set的操作
java.customization.AvoidUseSetFuncInGetMethodRule.rule.desc=避免在get开头的方法中使用set的操作。

java.customization.AvoidGetEnumUseForStatementRule.rule.msg=避免在枚举中通过for语句获取枚举值
java.customization.AvoidGetEnumUseForStatementRule.violation.msg=避免在枚举中通过for语句获取枚举值
java.customization.AvoidGetEnumUseForStatementRule.rule.desc=避免在枚举中通过for语句获取枚举值，因为你无法预估调用该方法的复杂度，\
  建议可以通过初始化Map来获取。

java.customization.AvoidOperateExternalVariInStreamForeachStmtsRule.rule.msg=避免在stream的forEach语句中操作外部变量
java.customization.AvoidOperateExternalVariInStreamForeachStmtsRule.violation.msg=避免在stream的forEach语句中操作外部变量
java.customization.AvoidOperateExternalVariInStreamForeachStmtsRule.rule.desc=stream是一种基于函数编程的模型，尽可能的应该\
  使用纯函数。详见：《effective java》第7章46条。


